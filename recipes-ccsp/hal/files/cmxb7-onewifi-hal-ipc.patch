From d80b9799a3690db3702e57bcc8f784a9f862a415 Mon Sep 17 00:00:00 2001
From: Dmytro Zelenets <Dmytro_Zelenets@comcast.com>
Date: Mon, 13 Feb 2023 22:08:39 +0200
Subject: [PATCH] CMXB7-4730: OneWifi, SM & BM HAL IPC implementation

Reason for change: implement IPC mechanism between OneWifi/RDK-Wifi-HAL and SM, BM
processes.
Test Procedure: None. Draft code.
Priority: P0
Risks: Low

Change-Id: I68b34819b28fd32a6245dbc7d2c77f87f9548151
Signed-off-by: Dmytro Zelenets <Dmytro_Zelenets@comcast.com>
---

diff --git wifi/Makefile.am wifi/Makefile.am
index 9a48bac..a98fdaf 100644
--- wifi/Makefile.am
+++ wifi/Makefile.am
@@ -17,11 +17,12 @@
 # limitations under the License.
 ##########################################################################
 AM_CFLAGS =
-
+AUTOMAKE_OPTIONS = subdir-objects
 ACLOCAL_AMFLAGS = -I m4
 
 lib_LTLIBRARIES = libhal_wifi.la
 
-libhal_wifi_la_CPPFLAGS =
-libhal_wifi_la_SOURCES = wifi_hal.c
+libhal_wifi_la_CPPFLAGS = -I../git/source/wifi/hal_ipc/client/ -D_GNU_SOURCE
+libhal_wifi_la_CFLAGS = -Werror -Wextra -Wno-pointer-sign -Wno-sign-compare -Wno-type-limits -Wno-format-truncation -Wno-poison-system-directories -Wno-discarded-qualifiers
+libhal_wifi_la_SOURCES = wifi_hal.c ./hal_ipc/client/client_hal_ipc_core.c ./hal_ipc/client/client_hal_ipc_processors.c ./hal_ipc/client/client_hal_ipc_api.c 
 libhal_wifi_la_LDFLAGS =
diff --git wifi/hal_ipc/client/client_hal_ipc_api.c wifi/hal_ipc/client/client_hal_ipc_api.c
new file mode 100644
index 0000000..f88bdff
--- /dev/null
+++ wifi/hal_ipc/client/client_hal_ipc_api.c
@@ -0,0 +1,1384 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include "client_hal_ipc_core.h"
+
+
+//used this variable for sm/bm process data synchronization
+static volatile BOOL sm_bm_socket_in_use = FALSE;
+
+static int send_to_sm_socket(hal_ipc_node_t *node, hal_ipc_processor_desc_t *desc)
+{
+    while (sm_bm_socket_in_use){ };
+
+    sm_bm_socket_in_use = TRUE;
+    if (hal_ipc_exec(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        sm_bm_socket_in_use = FALSE;
+        return -1;
+    }
+    sm_bm_socket_in_use = FALSE;
+
+    return 0;
+}
+
+static int send_to_bm_socket(hal_ipc_node_t *node, hal_ipc_processor_desc_t *desc)
+{
+    while (sm_bm_socket_in_use){ };
+
+    sm_bm_socket_in_use = TRUE;
+    if (hal_ipc_exec(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        sm_bm_socket_in_use = FALSE;
+        return -1;
+    }
+    sm_bm_socket_in_use = FALSE;
+
+    return 0;
+}
+
+
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_setRadioStatsEnable( INT radioIndex,
+                              BOOL enabled)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_set_radio_stats_enable);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &radioIndex, &enabled, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, NULL, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getSSIDNumberOfEntries(ULONG *numEntries)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_ssid_num_of_entries);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client", __func__, __LINE__);
+        return -1;
+    }
+
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    desc->len = sizeof(hal_ipc_processor_desc_t);
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, numEntries, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getApAssociatedDeviceStats(INT apIndex,
+                                    mac_address_t *clientMacAddress,
+                                    wifi_associated_dev_stats_t *associated_dev_stats,
+                                    ULLONG *handle)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_ap_assoc_dev_stats);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, clientMacAddress, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, associated_dev_stats, handle, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getRadioChannelStats(INT radioIndex,
+                              wifi_channelStats_t *input_output_channelStats_array,
+                              INT array_size)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_radio_chan_stats);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &radioIndex, input_output_channelStats_array, &array_size, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, input_output_channelStats_array, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_startNeighborScan( INT apIndex,
+                            wifi_neighborScanMode_t scan_mode,
+                            INT dwell_time,
+                            UINT chan_num,
+                            UINT *chan_list)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_start_neighbor_scan);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, &scan_mode, &dwell_time, &chan_num, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, chan_list, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getNeighboringWiFiStatus(INT radioIndex,
+                                  wifi_neighbor_ap2_t **neighbor_ap_array,
+                                  UINT *output_array_size)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_neighbor_wifi_status);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &radioIndex, NULL, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    *neighbor_ap_array = (wifi_neighbor_ap2_t*) malloc(desc->out.get_neighbor_wifi_status.output_array_size*sizeof(wifi_neighbor_ap2_t));
+    if (!(*neighbor_ap_array)) {
+        hal_wifi_print("%s:%d: scratch_buf_size:%d scratch_buf:%p\n", __func__, __LINE__, desc->scratch_buf_size, desc->scratch_buf);
+        if ((desc->scratch_buf_size != 0) && (desc->scratch_buf != NULL)) {
+            free(desc->scratch_buf);
+            desc->scratch_buf = NULL;
+        }
+        hal_wifi_print("%s:%d: failed to allocate memory for %d wifi_neighbor_ap2_t structs\n", __func__, __LINE__, desc->out.get_neighbor_wifi_status.output_array_size);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, *neighbor_ap_array, output_array_size, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getSSIDTrafficStats2(INT ssidIndex,
+                              wifi_ssidTrafficStats2_t *output_struct)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_ssid_traffic_stats2);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &ssidIndex, NULL, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, output_struct, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getApAssociatedDeviceRxStatsResult(INT radioIndex,
+                                            mac_address_t *clientMacAddress,
+                                            wifi_associated_dev_rate_info_rx_stats_t **stats_array,
+                                            UINT *output_array_size,
+                                            ULLONG *handle)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_ap_assoc_dev_rx_stats_result);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &radioIndex, clientMacAddress, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    *stats_array = (wifi_associated_dev_rate_info_rx_stats_t *) malloc(desc->out.get_ap_assoc_dev_rx_stats_result.output_array_size * sizeof(wifi_associated_dev_rate_info_rx_stats_t));
+
+    if (*stats_array == NULL){
+        hal_wifi_print("%s:%d: failed to allocate memory for %d wifi_associated_dev_rate_info_rx_stats_t structs\n", __func__, __LINE__, desc->out.get_ap_assoc_dev_rx_stats_result.output_array_size);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, *stats_array, output_array_size, handle, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getSSIDEnable( INT ssidIndex,
+                        BOOL *output_bool)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_ssid_enable);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &ssidIndex, NULL, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, output_bool, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getSSIDRadioIndex( INT ssidIndex,
+                            INT *radioIndex)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_ssid_radio_index);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &ssidIndex, NULL, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, radioIndex, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getSSIDNameStatus(INT apIndex, CHAR *output_string)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_ssid_name_status);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, NULL, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, output_string, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getApName(INT apIndex, CHAR *output_string)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_ap_name);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, NULL, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, output_string, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getNeighborReportActivation(UINT apIndex, BOOL *activate)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_neighbor_report_activation);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, NULL, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, activate, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getBSSTransitionActivation(UINT apIndex, BOOL *activate)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_bss_transition_activation);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, NULL, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, activate, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+int ipc_wifi_getApAssociatedDeviceDiagnosticResult3(int ap_index,
+                                                wifi_associated_dev3_t **associated_dev_array,
+                                                unsigned int *output_array_size)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_ap_assoc_dev_diag_result3);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call server\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &ap_index, NULL, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    *associated_dev_array = (wifi_associated_dev3_t*) malloc(desc->out.get_ap_assoc_dev_diag_result3.num*sizeof(wifi_associated_dev3_t));
+
+    if (!(*associated_dev_array)){
+        hal_wifi_print("%s:%d: failed to allocate memory for %d wifi_associated_dev3_t structs\n", __func__, __LINE__, desc->out.get_ap_assoc_dev_diag_result3.num);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, *associated_dev_array, output_array_size, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        free(*associated_dev_array);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getApAssociatedClientDiagnosticResult( INT apIndex,
+                                                char *mac_addr,
+                                                wifi_associated_dev3_t *dev_conn)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_ap_assoc_client_diag_result);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, mac_addr, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, dev_conn, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getRadioOperatingFrequencyBand(INT radioIndex,
+                                        CHAR *output_string)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_radio_operating_freq_band);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &radioIndex, NULL, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, output_string, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getRadioNumberOfEntries(ULONG *output)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_radio_num_of_entries);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    desc->len = sizeof(hal_ipc_processor_desc_t);
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, output, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_steering_eventUnregister(void)
+{
+    wifi_steering_eventCB_t registered_steering_event_callback = hal_ipc_get_client_steering_callback();
+
+    if(registered_steering_event_callback){
+        hal_ipc_set_client_steering_callback(NULL);
+    }
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+int ipc_wifi_steering_eventRegister(wifi_steering_eventCB_t event_cb)
+{
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    if(!event_cb){
+        return -1;
+    }
+
+    if (client_create_hal_ipc_node(hal_ipc_node_type_notification_server) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create notification server\n", __func__, __LINE__);
+        return -1;
+    }
+
+    hal_ipc_set_client_steering_callback(event_cb);
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+int ipc_wifi_RMBeaconRequestCallbackRegister(unsigned int apIndex, wifi_RMBeaconReport_callback cb_fn)
+{
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    if(!cb_fn){
+        hal_wifi_print("%s : ERROR: wifi_RMBeaconReport_callback is NULL. Exit.\n", __func__);
+        return -1;
+    }
+
+    if (client_create_hal_ipc_node(hal_ipc_node_type_notification_server) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create notification server\n", __func__, __LINE__);
+        return -1;
+    }
+
+    hal_ipc_set_client_rm_beacon_report_callback(apIndex, cb_fn); 
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+int ipc_wifi_RMBeaconRequestCallbackUnregister(unsigned int apIndex, wifi_RMBeaconReport_callback cb_fn)
+{
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    hal_ipc_set_client_rm_beacon_report_callback(apIndex, NULL);
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+int ipc_wifi_BTMQueryRequest_callback_register( unsigned int apIndex,
+                                                wifi_BTMQueryRequest_callback btmQueryCallback,
+                                                wifi_BTMResponse_callback btmResponseCallback)
+{
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    if(!btmQueryCallback){
+        hal_wifi_print("%s : ERROR: wifi_BTMQueryRequest_callback is NULL. Exit.\n", __func__);
+        return -1;
+    }
+
+    if(!btmResponseCallback){
+        hal_wifi_print("%s : ERROR: wifi_BTMResponse_callback is NULL. Exit.\n", __func__);
+        return -1;
+    }
+
+    if (client_create_hal_ipc_node(hal_ipc_node_type_notification_server) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create notification server\n", __func__, __LINE__);
+        return -1;
+    }
+
+    hal_ipc_set_client_btm_query_request_callback(apIndex, btmQueryCallback, btmResponseCallback);
+    return 0;
+}
+
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_mgmt_frame_callbacks_register(wifi_receivedMgmtFrame_callback mgmtRxCallback)
+{
+    if(!mgmtRxCallback){
+        return -1;
+    }
+
+    if (client_create_hal_ipc_node(hal_ipc_node_type_notification_server) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create notification server\n", __func__, __LINE__);
+        return -1;
+    }
+
+    //hal_ipc_set_client_mgmt_frame_callback(mgmtRxCallback);
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getApAssociatedDeviceTxStatsResult(INT radioIndex,
+                                            mac_address_t *clientMacAddress,
+                                            wifi_associated_dev_rate_info_tx_stats_t **stats_array,
+                                            UINT *output_array_size,
+                                            ULLONG *handle)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_ap_assoc_dev_tx_stats_result);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &radioIndex, clientMacAddress, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    *stats_array = (wifi_associated_dev_rate_info_tx_stats_t *) malloc(desc->out.get_ap_assoc_dev_tx_stats_result.output_array_size * sizeof(wifi_associated_dev_rate_info_tx_stats_t));
+
+    if (*stats_array == NULL){
+        hal_wifi_print("%s:%d: failed to allocate memory for %d wifi_associated_dev_rate_info_tx_stats_t structs\n", __func__, __LINE__, desc->out.get_ap_assoc_dev_tx_stats_result.output_array_size);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, *stats_array, output_array_size, handle, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_steering_setGroup( UINT steeringgroupIndex, 
+                                wifi_steering_apConfig_t *cfg_2, 
+                                wifi_steering_apConfig_t *cfg_5)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_steering_set_group);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &steeringgroupIndex, cfg_2, cfg_5, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, cfg_2, cfg_5, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_steering_clientSet(UINT steeringgroupIndex,
+                            INT apIndex,
+                            mac_address_t client_mac,
+                            wifi_steering_clientConfig_t *config)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_steering_client_set);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &steeringgroupIndex, &apIndex, client_mac, config, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, config, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return desc->ret;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_steering_clientRemove(UINT steeringgroupIndex,
+                               INT apIndex,
+                               mac_address_t client_mac)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_steering_client_remove);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+
+    if ((input_func != NULL) && (input_func(desc, &steeringgroupIndex, &apIndex, client_mac, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return desc->ret;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_steering_clientDisconnect(UINT steeringgroupIndex,
+                                   INT apIndex,
+                                   mac_address_t client_mac,
+                                   wifi_disconnectType_t type,
+                                   UINT reason)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_steering_client_disconnect);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+
+    if ((input_func != NULL) && (input_func(desc, &steeringgroupIndex, &apIndex, client_mac, &type, &reason) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return desc->ret;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_setBTMRequest(UINT apIndex,
+                       CHAR *peerMac,
+                       wifi_BTMRequest_t *request)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_set_btm_request);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, peerMac, request, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return desc->ret;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getSSIDName(INT apIndex,
+                     CHAR *output_string)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_ssid_name);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, NULL, NULL, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) && 
+            (output_func(desc, output_string, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_setRMBeaconRequest(UINT apIndex,
+                            CHAR *peer,
+                            wifi_BeaconRequest_t *in_request,
+                            UCHAR *out_DialogToken)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_set_rm_beacon_request);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, peer, in_request, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, out_DialogToken, NULL, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getAssociationReqIEs(UINT apIndex,
+                              const mac_address_t *clientMacAddress,
+                              CHAR *req_ies,
+                              UINT req_ies_size,
+                              UINT *req_ies_len)
+{
+    // This function comes from wave-api ONLY
+    // Extended API functions (not part of the existing WIFI-HAL)
+
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_association_req_ies);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    mac_address_t *client_mac_addr = (mac_address_t*) malloc(sizeof(mac_address_t));
+
+    if(!client_mac_addr)
+    {
+        hal_wifi_print("%s:%d: Failed to allocate memory for mac_address_t\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if(!memcpy((unsigned char*) client_mac_addr,
+                (unsigned char*) clientMacAddress,
+                sizeof(mac_address_t)))
+    {
+        hal_wifi_print("%s:%d: Failed memcpy mac_address_t\n", __func__, __LINE__);
+        free(client_mac_addr);
+        return -1;
+    }
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, client_mac_addr, &req_ies_size, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        free(client_mac_addr);
+        return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        free(client_mac_addr);
+        return -1;
+    }
+
+    if ((output_func != NULL) &&
+            (output_func(desc, req_ies, req_ies_len, NULL, NULL, NULL)) != 0) {
+        hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+        free(client_mac_addr);
+        return -1;
+    }
+
+    free(client_mac_addr);
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_setNeighborReports(UINT apIndex,
+                            UINT numNeighborReports,
+                            wifi_NeighborReport_t *neighborReports)
+{
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func;
+    hal_ipc_processor_desc_t *desc;
+
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_set_neighbor_reports);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+        hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+        return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, &numNeighborReports, neighborReports, NULL, NULL) != 0)) {
+        hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+        hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return desc->ret;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_setNeighborReportActivation(UINT apIndex, BOOL activate)
+{
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func;
+    hal_ipc_processor_desc_t *desc;
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_set_neighbor_report_activation);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+    hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+    return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, &activate, NULL, NULL, NULL) != 0)) {
+    hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+    return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+    hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+    return -1;
+    }
+
+    return desc->ret;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getRadioIfName(INT radioIndex, CHAR *output_string)
+{
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_radio_if_name);
+    // wm2, sm
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_sm_client)) == NULL) {
+    hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+    return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &radioIndex, NULL, NULL, NULL, NULL) != 0)) {
+    hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+    return -1;
+    }
+
+    if (send_to_sm_socket(node, desc) != 0) {
+    hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+    return -1;
+    }
+
+    if ((output_func != NULL) &&
+    (output_func(desc, output_string, NULL, NULL, NULL, NULL)) != 0) {
+    hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+    return -1;
+    }
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT ipc_wifi_getApNumDevicesAssociated(INT apIndex, ULONG *output_ulong)
+{
+    hal_wifi_print("hal-wifi-generic %s : Enter\n", __func__);
+    hal_ipc_node_t *node;
+    hal_ipc_processor_t	input_func, output_func;
+    hal_ipc_processor_desc_t *desc;
+
+    desc  = client_get_processor_desc(hal_ipc_desc_type_get_ap_num_assoc_devs);
+
+    if ((node = client_create_hal_ipc_node(hal_ipc_node_type_sync_call_bm_client)) == NULL) {
+    hal_wifi_print("%s:%d: Failed to create sync call client\n", __func__, __LINE__);
+    return -1;
+    }
+
+    input_func = desc->ipc_processor[processor_type_ipc_client_input];
+    output_func = desc->ipc_processor[processor_type_ipc_client_output];
+
+    if ((input_func != NULL) && (input_func(desc, &apIndex, NULL, NULL, NULL, NULL) != 0)) {
+    hal_wifi_print("%s:%d: Client input processor failed\n", __func__, __LINE__);
+    return -1;
+    }
+
+    if (send_to_bm_socket(node, desc) != 0) {
+    hal_wifi_print("%s:%d: ipc  processor failed\n", __func__, __LINE__);
+    return -1;
+    }
+
+    if ((output_func != NULL) &&
+    (output_func(desc, output_ulong, NULL, NULL, NULL, NULL)) != 0) {
+    hal_wifi_print("%s:%d: Client output processor failed\n", __func__, __LINE__);
+    return -1;
+    }
+    return 0;
+}
+
+
+
+
diff --git wifi/hal_ipc/client/client_hal_ipc_api.h wifi/hal_ipc/client/client_hal_ipc_api.h
new file mode 100644
index 0000000..5639fef
--- /dev/null
+++ wifi/hal_ipc/client/client_hal_ipc_api.h
@@ -0,0 +1,209 @@
+#ifndef HAL_IPC_CLIENT_H
+#define HAL_IPC_CLIENT_H
+#include "client_hal_ipc_core.h"
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_setRadioStatsEnable(   INT radioIndex,
+                                    BOOL enabled);
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getSSIDNumberOfEntries(ULONG *numEntries);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getApAssociatedDeviceStats(INT apIndex,
+                                        mac_address_t *clientMacAddress,
+                                        wifi_associated_dev_stats_t *associated_dev_stats,
+                                        ULLONG *handle);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getRadioChannelStats(  INT radioIndex,
+                                    wifi_channelStats_t *input_output_channelStats_array,
+                                    INT array_size);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_startNeighborScan( INT apIndex,
+                                wifi_neighborScanMode_t scan_mode,
+                                INT dwell_time,
+                                UINT chan_num,
+                                UINT *chan_list);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getNeighboringWiFiStatus(  INT radioIndex,
+                                        wifi_neighbor_ap2_t **neighbor_ap_array,
+                                        UINT *output_array_size);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getSSIDTrafficStats2(  INT ssidIndex,
+                                    wifi_ssidTrafficStats2_t *output_struct);
+
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getApAssociatedDeviceRxStatsResult(INT radioIndex,
+                                                mac_address_t *clientMacAddress,
+                                                wifi_associated_dev_rate_info_rx_stats_t **stats_array,
+                                                UINT *output_array_size,
+                                                ULLONG *handle);
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getSSIDEnable( INT ssidIndex,
+                            BOOL *output_bool);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getSSIDRadioIndex( INT ssidIndex,
+                                INT *radioIndex);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getSSIDNameStatus( INT apIndex,
+                                CHAR *output_string);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getApName( INT apIndex,
+                        CHAR *output_string);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getNeighborReportActivation(   UINT apIndex,
+                                            BOOL *activate);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getBSSTransitionActivation(UINT apIndex,
+                                        BOOL *activate);
+
+
+//------------------------------------------------------------------------------
+int ipc_wifi_getApAssociatedDeviceDiagnosticResult3(int ap_index,
+                                                    wifi_associated_dev3_t **associated_dev_array,
+                                                    unsigned int *output_array_size);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getApAssociatedClientDiagnosticResult( INT apIndex,
+                                                    char *mac_addr,
+                                                    wifi_associated_dev3_t *dev_conn);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getRadioOperatingFrequencyBand(INT radioIndex,
+                                            CHAR *output_string);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getRadioNumberOfEntries(ULONG *output);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getApAssociatedDeviceTxStatsResult(INT radioIndex,
+                                                mac_address_t *clientMacAddress,
+                                                wifi_associated_dev_rate_info_tx_stats_t **stats_array,
+                                                UINT *output_array_size,
+                                                ULLONG *handle);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_steering_setGroup( UINT steeringgroupIndex,
+                                wifi_steering_apConfig_t *cfg_2,
+                                wifi_steering_apConfig_t *cfg_5);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_steering_clientSet(UINT steeringgroupIndex,
+                                INT apIndex,
+                                mac_address_t client_mac,
+                                wifi_steering_clientConfig_t *config);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_steering_clientRemove( UINT steeringgroupIndex,
+                                    INT apIndex,
+                                    mac_address_t client_mac);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_steering_clientDisconnect( UINT steeringgroupIndex,
+                                        INT apIndex,
+                                        mac_address_t client_mac,
+                                        wifi_disconnectType_t type,
+                                        UINT reason);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_setBTMRequest( UINT apIndex,
+                            CHAR *peerMac,
+                            wifi_BTMRequest_t *request);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getSSIDName(   INT apIndex,
+                            CHAR *output_string);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_setRMBeaconRequest(UINT apIndex,
+                                CHAR *peer,
+                                wifi_BeaconRequest_t *in_request,
+                                UCHAR *out_DialogToken);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getAssociationReqIEs(  UINT apIndex,
+                                    const mac_address_t *clientMacAddress,
+                                    CHAR *req_ies,
+                                    UINT req_ies_size,
+                                    UINT *req_ies_len);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_setNeighborReports(UINT apIndex,
+                                UINT numNeighborReports,
+                                wifi_NeighborReport_t *neighborReports);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_steering_eventUnregister(void);
+
+
+//------------------------------------------------------------------------------
+int ipc_wifi_steering_eventRegister(wifi_steering_eventCB_t event_cb);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_mgmt_frame_callbacks_register(wifi_receivedMgmtFrame_callback mgmtRxCallback);
+
+
+//--------------------------------------------------------------------------------------------------
+int ipc_wifi_RMBeaconRequestCallbackRegister(unsigned int apIndex, wifi_RMBeaconReport_callback cb_fn);
+
+
+//--------------------------------------------------------------------------------------------------
+int ipc_wifi_RMBeaconRequestCallbackUnregister(unsigned int apIndex, wifi_RMBeaconReport_callback cb_fn);
+
+
+//--------------------------------------------------------------------------------------------------
+int ipc_wifi_BTMQueryRequest_callback_register( unsigned int apIndex,
+                                                wifi_BTMQueryRequest_callback btmQueryCallback,
+                                                wifi_BTMResponse_callback btmResponseCallback);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getRadioIfName(INT radioIndex, CHAR *output_string);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_setNeighborReportActivation(UINT apIndex, BOOL activate);
+
+
+//------------------------------------------------------------------------------
+INT ipc_wifi_getApNumDevicesAssociated(INT apIndex, ULONG *output_ulong);
+
+
+#endif // HAL_IPC_CLIENT_H
diff --git wifi/hal_ipc/client/client_hal_ipc_core.c wifi/hal_ipc/client/client_hal_ipc_core.c
new file mode 100644
index 0000000..34117cf
--- /dev/null
+++ wifi/hal_ipc/client/client_hal_ipc_core.c
@@ -0,0 +1,1334 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <string.h>
+#include <assert.h>
+#include "client_hal_ipc_core.h"
+
+hal_ipc_node_t  g_ipc_node[hal_ipc_node_type_max];
+
+BOOL g_notification_server_started = false;
+
+hal_ipc_processor_desc_t d;
+
+hal_ipc_processor_desc_t    client_processor_desc[hal_ipc_desc_type_max] = {
+    {
+        hal_ipc_desc_type_set_radio_stats_enable,   // type
+        "wifi_setRadioStatsEnable",                 // name
+        {                                           // ipc_processor
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,                                          // len 
+        0,                                          // ret
+        {0},                                        // union in
+        {0},                                        // union out
+        NULL,                                       // scratch_buf pointer
+        0                                           // scratch_buf_size
+    },
+    {
+        hal_ipc_desc_type_get_ssid_num_of_entries,
+        "wifi_getSSIDNumberOfEntries",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_ap_assoc_dev_stats,
+        "wifi_getApAssociatedDeviceStats",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_radio_chan_stats,
+        "wifi_getRadioChannelStats",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_start_neighbor_scan,
+        "wifi_startNeighborScan",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_neighbor_wifi_status,
+        "wifi_getNeighboringWiFiStatus",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_ssid_traffic_stats2,
+        "wifi_getSSIDTrafficStats2",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_ap_assoc_dev_rx_stats_result,
+        "wifi_getApAssociatedDeviceRxStatsResult",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_ssid_enable,
+        "wifi_getSSIDEnable",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_ssid_radio_index,
+        "wifi_getSSIDRadioIndex",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_ssid_name_status,
+        "wifi_getSSIDNameStatus",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_ap_name,
+        "wifi_getApName",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_neighbor_report_activation,
+        "wifi_getNeighborReportActivation",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_bss_transition_activation,
+        "wifi_getBSSTransitionActivation",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_ap_assoc_dev_diag_result3,
+        "wifi_getApAssociatedDeviceDiagnosticResult3",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_ap_assoc_client_diag_result,
+        "wifi_getApAssociatedClientDiagnosticResult",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_radio_operating_freq_band,
+        "wifi_getRadioOperatingFrequencyBand",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_radio_num_of_entries,
+        "wifi_getRadioNumberOfEntries",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_ap_assoc_dev_tx_stats_result,
+        "wifi_getApAssociatedDeviceTxStatsResult",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_steering_set_group,
+        "wifi_steering_setGroup",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_steering_client_set,
+        "wifi_steering_clientSet",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_steering_client_remove,
+        "wifi_steering_clientRemove",
+        {
+            ipc_input_client,
+            NULL,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_steering_client_disconnect,
+        "wifi_steering_clientDisconnect",
+        {
+            ipc_input_client,
+            NULL,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_set_btm_request,
+        "wifi_setBTMRequest",
+        {
+            ipc_input_client,
+            NULL,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_ssid_name,
+        "wifi_getSSIDName",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_set_rm_beacon_request,
+        "wifi_setRMBeaconRequest",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_association_req_ies,
+        "wifi_getAssociationReqIEs",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_set_neighbor_reports,
+        "wifi_setNeighborReports",
+        {
+            ipc_input_client,
+            NULL,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_set_neighbor_report_activation,
+        "wifi_setNeighborReportActivation",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_radio_if_name,
+        "wifi_getRadioIfName",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_get_ap_num_assoc_devs,
+        "wifi_getApNumDevicesAssociated",
+        {
+            ipc_input_client,
+            ipc_output_client,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_steering_unregister,
+        "wifi_steering_eventUnregister",
+        {
+            ipc_input_client,
+            NULL,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_steering_register,
+        "wifi_steering_eventRegister",
+        {
+            ipc_input_client,
+            NULL,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_steering_event,
+        "steering event notification",
+        {
+            NULL,
+            NULL,
+            NULL,
+            NULL,
+            server_ipc_notification_output
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_mgmt_frame_callback_register,
+        "wifi_newApAssociatedDevice_callback_register",
+        {
+            ipc_input_client,
+            NULL,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_desc_type_mgmt_frame_event,
+        "mgmt frame event notification",
+        {
+            NULL,
+            NULL,
+            NULL,
+            NULL,
+            server_ipc_notification_output
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_rm_beacon_request_register,
+        "wifi_RMBeaconRequestCallbackRegister",
+        {
+            ipc_input_client,
+            NULL,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_rm_beacon_report_event,
+        "RM beacon report event notification",
+        {
+            NULL,
+            NULL,
+            NULL,
+            NULL,
+            server_ipc_notification_output
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_btm_query_request_register,
+        "wifi_BTMQueryRequest_callback_register",
+        {
+            ipc_input_client,
+            NULL,
+            NULL,
+            NULL,
+            NULL
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_btm_query_request_event,
+        "BTM query request event notification",
+        {
+            NULL,
+            NULL,
+            NULL,
+            NULL,
+            server_ipc_notification_output
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    },
+    {
+        hal_ipc_btm_response_event,
+        "BTM response event notification",
+        {
+            NULL,
+            NULL,
+            NULL,
+            NULL,
+            server_ipc_notification_output
+        },
+        0,
+        0,
+        {0},
+        {0},
+        NULL,
+        0
+    }
+};
+
+//**************************************************************************************************
+// Function pointer to store client's callback for steering event
+wifi_steering_eventCB_t client_registered_steering_callback = NULL;
+
+//--------------------------------------------------------------------------------------------------
+void hal_ipc_set_client_steering_callback(wifi_steering_eventCB_t client_steering_event_callback)
+{
+    // Don't check for NULL pointer here for the purpose of Unregistering clients callback
+    client_registered_steering_callback = client_steering_event_callback;
+}
+
+//--------------------------------------------------------------------------------------------------
+wifi_steering_eventCB_t hal_ipc_get_client_steering_callback(void)
+{
+    return client_registered_steering_callback;
+}
+
+//**************************************************************************************************
+// Array of function pointers to store client's RM beacon report callback per vap
+wifi_RMBeaconReport_callback rm_beacon_report_cb_fn_array[MAX_VAP];
+
+//--------------------------------------------------------------------------------------------------
+void hal_ipc_set_client_rm_beacon_report_callback(unsigned int ap_index, wifi_RMBeaconReport_callback vap_cb_fn)
+{
+    if (ap_index >= MAX_VAP) {
+        hal_wifi_print("%s:%d: ERROR: AP index %d out of range. MAX_VAP: %d.\n", __func__, __LINE__, ap_index, MAX_VAP);
+        return;
+    }
+
+    if (vap_cb_fn) {
+        hal_wifi_print("%s:%d: registered RM beacon request callback for AP index %d.\n", __func__, __LINE__, ap_index);
+    } else {
+        hal_wifi_print("%s:%d: RM beacon request callback for AP index %d set to NULL (Unregistered).\n", __func__, __LINE__, ap_index);
+    }
+
+    // Don't check for NULL pointer here for the purpose of Unregistering clients callback
+    rm_beacon_report_cb_fn_array[ap_index] = vap_cb_fn;
+}
+
+//--------------------------------------------------------------------------------------------------
+wifi_RMBeaconReport_callback    hal_ipc_get_client_rm_beacon_report_callback(unsigned int ap_index)
+{
+    if (ap_index >= MAX_VAP) {
+        hal_wifi_print("%s:%d: ERROR: AP index %d out of range. MAX_VAP: %d.\n", __func__, __LINE__, ap_index, MAX_VAP);
+        return NULL;
+    }
+
+    return rm_beacon_report_cb_fn_array[ap_index];
+}
+
+//**************************************************************************************************
+// Array of function pointers to store client's BTM query request callback per vap
+typedef struct {
+    wifi_BTMQueryRequest_callback   vap_btm_query_cb;
+    wifi_BTMResponse_callback       vap_btm_response_cb;
+} hal_ipc_btm_query_request_cb_set_t;
+
+hal_ipc_btm_query_request_cb_set_t btm_query_req_callback_array[MAX_VAP];
+
+//--------------------------------------------------------------------------------------------------
+void hal_ipc_set_client_btm_query_request_callback(unsigned int ap_index,
+                                                wifi_BTMQueryRequest_callback btmQueryCallback,
+                                                wifi_BTMResponse_callback btmResponseCallback)
+{
+    if (ap_index >= MAX_VAP) {
+        hal_wifi_print("%s:%d: ERROR: AP index %d out of range. MAX_VAP: %d.\n", __func__, __LINE__, ap_index, MAX_VAP);
+        return;
+    }
+
+    hal_wifi_print("%s:%d: registered BTM query request callback for AP index %d.\n", __func__, __LINE__, ap_index);
+
+    btm_query_req_callback_array[ap_index].vap_btm_query_cb = btmQueryCallback;
+    btm_query_req_callback_array[ap_index].vap_btm_response_cb = btmResponseCallback;
+}
+
+//--------------------------------------------------------------------------------------------------
+wifi_BTMQueryRequest_callback   hal_ipc_get_btm_query_request_callback(unsigned int ap_index)
+{
+    if (ap_index >= MAX_VAP) {
+        hal_wifi_print("%s:%d: ERROR: AP index %d out of range. MAX_VAP: %d.\n", __func__, __LINE__, ap_index, MAX_VAP);
+        return NULL;
+    }
+
+    return btm_query_req_callback_array[ap_index].vap_btm_query_cb;
+}
+
+//--------------------------------------------------------------------------------------------------
+wifi_BTMResponse_callback   hal_ipc_get_btm_response_callback(unsigned int ap_index)
+{
+    if (ap_index >= MAX_VAP) {
+        hal_wifi_print("%s:%d: ERROR: AP index %d out of range. MAX_VAP: %d.\n", __func__, __LINE__, ap_index, MAX_VAP);
+        return NULL;
+    }
+
+    return btm_query_req_callback_array[ap_index].vap_btm_response_cb;
+}
+
+
+#if 0
+//**************************************************************************************************
+// Function to store callback function to get AP associated device diagnostic result3
+app_get_ap_assoc_dev_diag_res3_t hal_ipc_get_ap_assoc_dev_diag_res3 = NULL;
+
+//--------------------------------------------------------------------------------------------------
+void hal_ipc_set_ap_assoc_dev_diag_res3(app_get_ap_assoc_dev_diag_res3_t get_ap_assoc_dev_diag_res3_callback)
+{
+    // check for NULL pointer here?
+    hal_ipc_get_ap_assoc_dev_diag_res3 = get_ap_assoc_dev_diag_res3_callback;
+}
+
+//--------------------------------------------------------------------------------------------------
+app_get_ap_assoc_dev_diag_res3_t hal_ipc_get_ap_assoc_dev_diag_res3_callback(void)
+{
+    return hal_ipc_get_ap_assoc_dev_diag_res3;
+}
+#endif
+
+
+
+#include <stdarg.h>
+
+void hal_wifi_print(const char *format, ...)
+{
+    va_list list;
+    FILE *fpg = NULL;
+
+    if ((access("/nvram/halWifiGenericDbg", R_OK)) == 0) {
+
+        fpg = fopen("/tmp/halWifiGeneric", "a+");
+        if (fpg == NULL) {
+            return;
+        }
+        va_start(list, format);
+        vfprintf(fpg, format, list);
+        va_end(list);
+        fflush(fpg);
+        fclose(fpg);
+    }
+
+    return;
+}
+
+
+//**************************************************************************************************
+//                      HAL IPC core functions
+//**************************************************************************************************
+//--------------------------------------------------------------------------------------------------
+hal_ipc_processor_desc_t *client_get_processor_desc(hal_ipc_desc_type_t type)
+{
+    return &client_processor_desc[type];
+}
+
+//--------------------------------------------------------------------------------------------------
+int hal_ipc_exec(hal_ipc_node_t *p_ipc_node, hal_ipc_processor_desc_t *desc)
+{
+    socklen_t len;
+    int cli_sock;
+    int nbytes, target_bytes;
+    unsigned int max_size = MAX_IPC_BUFF;
+    struct sockaddr_un cli_sockaddr, srv_sockaddr;
+    unsigned char *tmp;
+    hal_ipc_processor_desc_t tmp_desc;
+
+    if ((cli_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
+        hal_wifi_print("%s:%d:server socket create failed err: %d\n", __func__, __LINE__, errno);
+        return -1;
+    }
+
+    cli_sockaddr.sun_family = AF_UNIX;
+    strcpy(cli_sockaddr.sun_path, p_ipc_node->node_path);
+    len = sizeof(cli_sockaddr);
+
+    unlink(p_ipc_node->node_path);
+    if (bind(cli_sock, (struct sockaddr *)&cli_sockaddr, len) == -1) {
+        hal_wifi_print("%s:%d:client socket bind failed err: %d\n", __func__, __LINE__, errno);
+        close(cli_sock);
+        return -1;
+    }
+
+    srv_sockaddr.sun_family = AF_UNIX;
+
+    switch (p_ipc_node->type) {
+        case hal_ipc_node_type_sync_call_sm_client:
+        case hal_ipc_node_type_sync_call_bm_client:
+            strcpy(srv_sockaddr.sun_path, "/tmp/hal_sync_server");
+            break;
+
+        case hal_ipc_node_type_notification_client:
+            strcpy(srv_sockaddr.sun_path, "/tmp/hal_notification_server");
+            break;
+
+        default:
+            hal_wifi_print("%s:%d: Assert!!!.\n", __func__, __LINE__);
+            assert(1);
+            break;
+    }
+
+    if ((setsockopt(cli_sock, SOL_SOCKET, SO_RCVBUF, &max_size ,sizeof(int))) < 0) {
+        hal_wifi_print("%s:%d:clientr socket size set failed err: %d\n", __func__, __LINE__, errno);
+        close(cli_sock);
+        return -1;
+    }
+
+    if ((setsockopt(cli_sock, SOL_SOCKET, SO_SNDBUF, &max_size ,sizeof(int))) < 0) {
+        hal_wifi_print("%s:%d:clientr socket size set failed err: %d\n", __func__, __LINE__, errno);
+        close(cli_sock);
+        return -1;
+    }
+
+    if (connect(cli_sock, (struct sockaddr *)&srv_sockaddr, len) == -1) {
+        hal_wifi_print("%s:%d:connect failed err: %d\n", __func__, __LINE__, errno);
+        close(cli_sock);
+        return -1;
+    }
+
+    hal_wifi_print("%s:%d: sending desc %s struct of size bytes %d\n",
+            __func__, __LINE__, desc->name, desc->len);
+
+
+    ///************************************************************************///
+    ///     SEND DATA TO SERVER FOR PROCESSING                                 ///
+    ///************************************************************************///
+    // desc->len is changed when client fill the descriptor structure.
+    // It might be more than sizeof(hal_ipc_processor_desc_t)
+    // in case of sending to server some structure or
+    // array of structures for processing.
+    // Anyway we need to check desc->len against value of socket max_size bytes.
+    if (sizeof(hal_ipc_processor_desc_t) > max_size) {
+        nbytes = 0;
+        target_bytes = 0;
+        tmp = (unsigned char *) desc;
+
+        while (target_bytes < sizeof(hal_ipc_processor_desc_t)) {
+            if ((nbytes = send(cli_sock, tmp, ((sizeof(hal_ipc_processor_desc_t) - target_bytes) > max_size) ? max_size : (sizeof(hal_ipc_processor_desc_t) - target_bytes), 0)) == -1) {
+                hal_wifi_print("%s:%d:sending desc in chunks failed err: %d\n", __func__, __LINE__, errno);
+                // if size of descriptor data is more than just descriptor struct
+                // it means that in ipc_input_client function we allocated
+                // some memory to pass buffered data to server,
+                // so we need to free it
+                if (desc->len > sizeof(hal_ipc_processor_desc_t)) {
+                    free(desc->scratch_buf);
+                }
+                close(cli_sock);
+                return -1;
+            }
+            tmp += nbytes;
+            target_bytes += nbytes;
+        }
+        nbytes = target_bytes;
+    }
+    else if ((nbytes = send(cli_sock, (unsigned char *)desc, desc->len, 0)) == -1) {
+        hal_wifi_print("%s:%d:sending desc failed err: %d\n", __func__, __LINE__, errno);
+        if (desc->len > sizeof(hal_ipc_processor_desc_t)) {
+            free(desc->scratch_buf);
+        }
+        close(cli_sock);
+        return -1;
+    }
+
+    target_bytes = 0;
+    nbytes = 0;
+
+    if (desc->len > sizeof(hal_ipc_processor_desc_t)) {
+       tmp = desc->scratch_buf;
+       while (target_bytes < desc->scratch_buf_size) {
+            if ((nbytes = send(cli_sock, tmp, ((desc->scratch_buf_size - target_bytes) > max_size) ? max_size : desc->scratch_buf_size - target_bytes, 0)) == -1) {
+                hal_wifi_print("%s:%d:sending desc in chunks failed err: %d\n", __func__, __LINE__, errno);
+                close(cli_sock);
+                free(desc->scratch_buf);
+                return -1;
+            }
+            tmp += nbytes;
+            target_bytes += nbytes;
+        }
+    }
+    hal_wifi_print("%s:%d: sent %d bytes from client\n", __func__, __LINE__, nbytes);
+
+    // free memory allocated (if any) in client parameters input function.
+    // if size of descriptor data is more than just descriptor struct
+    // it means that in ipc_input_client function we allocated
+    // some memory to pass buffered data to server,
+    // so we need to free it after send
+    // because we don't need it anymore
+    if (desc->len > sizeof(hal_ipc_processor_desc_t)) {
+        free(desc->scratch_buf);
+    }
+
+    // re-init scratch_buf pointer of current descriptor
+    // to re-write the old(freed) value
+    desc->scratch_buf = NULL;
+
+    if (p_ipc_node->type == hal_ipc_node_type_notification_client) {
+        close(cli_sock);
+        return 0;
+    }
+
+    ///************************************************************************///
+    ///     RECEIVE DATA FROM SERVER                                           ///
+    ///************************************************************************///
+    nbytes = 0;
+    target_bytes = 0;
+    tmp = (unsigned char*) &tmp_desc;
+
+    if (sizeof(hal_ipc_processor_desc_t) > max_size) {
+        while(target_bytes < sizeof(hal_ipc_processor_desc_t))
+        {
+            if (((nbytes = recv(cli_sock, tmp, (sizeof(hal_ipc_processor_desc_t) - target_bytes > max_size) ? max_size : (sizeof(hal_ipc_processor_desc_t) - target_bytes), 0)) == -1) || (nbytes == 0)) {
+                hal_wifi_print("%s:%d:receiving command response failed err: %d data len:%d\n", __func__, __LINE__, errno, nbytes);
+                close(cli_sock);
+                return -1;
+            }
+            tmp += nbytes;
+            target_bytes += nbytes;
+        }
+    } else if (((nbytes = recv(cli_sock, (unsigned char *)desc, sizeof(hal_ipc_processor_desc_t), 0)) == -1) || (nbytes == 0)) {
+        hal_wifi_print("%s:%d:receiving command response failed err: %d data len:%d\n", __func__, __LINE__, errno, nbytes);
+        close(cli_sock);
+        return -1;
+    }
+
+    if (!memcpy((unsigned char*) desc, (unsigned char*) &tmp_desc, sizeof(hal_ipc_processor_desc_t))) {
+        hal_wifi_print("%s:%d: FAILED to copy descriptor of %s from temporary variable.\n", __func__, __LINE__, desc->name);
+        close(cli_sock);
+        return -1;
+    }
+
+    // check if there is more data to be received
+    if (desc->len == sizeof(hal_ipc_processor_desc_t)) {
+        hal_wifi_print("%s:%d: Received bytes: %d\n", __func__, __LINE__, target_bytes);
+        close(cli_sock);
+        return 0;
+    }
+
+    // check data size
+    // received vs expected
+    //assert(target_bytes == desc->len);
+    //assert(desc->scratch_buf_size == (desc->len - sizeof(hal_ipc_processor_desc_t)));
+
+    desc->scratch_buf = malloc(desc->scratch_buf_size);         // free in output function
+    if (!desc->scratch_buf) {
+        hal_wifi_print("%s:%d: FAILED to allocate %d bytes for scratch buf of desc %s.\n", __func__, __LINE__, desc->scratch_buf_size, desc->name);
+        close(cli_sock);
+        return -1;
+    }
+    memset(desc->scratch_buf, 0, desc->scratch_buf_size);
+    tmp = desc->scratch_buf;
+
+    target_bytes = 0;
+    nbytes = 0;
+
+    if (desc->scratch_buf_size > max_size) {
+        while (target_bytes < desc->scratch_buf_size) {
+            if (((nbytes = recv(cli_sock, tmp, (desc->scratch_buf_size - target_bytes) > max_size ? max_size : (desc->scratch_buf_size - target_bytes), 0)) == -1) || (nbytes == 0)) {
+                hal_wifi_print("%s:%d:receiving desc scratch buf in chunks failed err: %d data len:%d\n", __func__, __LINE__, errno, nbytes);
+                free(desc->scratch_buf);
+                close(cli_sock);
+                return -1;
+            }
+            tmp += nbytes;
+            target_bytes += nbytes;
+        }
+        nbytes = target_bytes;
+    } else if (((nbytes = recv(cli_sock, (unsigned char *)tmp, desc->scratch_buf_size, 0)) == -1) || (nbytes == 0)) {
+        hal_wifi_print("%s:%d:receiving command response failed err: %d data len:%d\n", __func__, __LINE__, errno, nbytes);
+        free(desc->scratch_buf);
+        close(cli_sock);
+        return -1;
+    }
+
+    hal_wifi_print("%s:%d: Received bytes: %d\n", __func__, __LINE__, nbytes);
+    close(cli_sock);
+
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+static void *hal_notification_server_func(void *arg)
+{
+    int cli_sock;
+    ssize_t	nbytes, target_bytes, max_size = MAX_IPC_BUFF;
+    socklen_t len;
+    struct sockaddr_un cli_sockaddr;
+    hal_ipc_processor_desc_t desc;
+    hal_ipc_processor_t	serv_processor;
+    hal_ipc_node_t *p_ipc_node = (hal_ipc_node_t *)arg;
+    unsigned char *tmp;
+    unsigned int total_sent = 0;
+    unsigned char break_cycle = 0;
+
+    if (((p_ipc_node->type != hal_ipc_node_type_notification_server) ||
+            (p_ipc_node->type != hal_ipc_node_type_sync_call_server)) == false) {
+        hal_wifi_print("%s:%d: Invalid node type: %d\n", __func__, __LINE__, p_ipc_node->type);
+        return NULL;
+    }
+
+    if ((p_ipc_node->srv_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
+        hal_wifi_print("%s:%d:server socket create failed err: %d\n", __func__, __LINE__, errno);
+        return NULL;
+    }
+
+    p_ipc_node->srv_sockaddr.sun_family = AF_UNIX;
+    strcpy(p_ipc_node->srv_sockaddr.sun_path, p_ipc_node->node_path);
+    len = sizeof(p_ipc_node->srv_sockaddr);
+
+    unlink(p_ipc_node->node_path);
+    if (bind(p_ipc_node->srv_sock, (struct sockaddr *)&p_ipc_node->srv_sockaddr, len) == -1) {
+        hal_wifi_print("%s:%d:server socket bind failed err: %d\n", __func__, __LINE__, errno);
+        close(p_ipc_node->srv_sock);
+        return NULL;
+    }
+
+    if ((setsockopt(p_ipc_node->srv_sock, SOL_SOCKET, SO_RCVBUF, &max_size ,sizeof(int))) < 0) {
+        hal_wifi_print("%s:%d:server socket size set failed err: %d\n", __func__, __LINE__, errno);
+        close(p_ipc_node->srv_sock);
+        return NULL;
+    }
+
+    if ((setsockopt(p_ipc_node->srv_sock, SOL_SOCKET, SO_SNDBUF, &max_size ,sizeof(int))) < 0) {
+        hal_wifi_print("%s:%d:server socket size set failed err: %d\n", __func__, __LINE__, errno);
+        close(p_ipc_node->srv_sock);
+        return NULL;
+    }
+
+    if (listen(p_ipc_node->srv_sock, 32) == -1) {
+        hal_wifi_print("%s:%d:server socket listen failed err: %d\n", __func__, __LINE__, errno);
+        close(p_ipc_node->srv_sock);
+        return NULL;
+    }
+
+    hal_wifi_print("%s:%d: Enter loop.\n", __func__, __LINE__);
+
+    while ((cli_sock = accept(p_ipc_node->srv_sock, (struct sockaddr *)&cli_sockaddr, &len)) != -1) {
+        ///**************************************************************************************///
+        ///                 RECEIVE NOTIFICATION DATA FROM CLIENT                                ///
+        ///**************************************************************************************///
+        break_cycle = 0;
+        nbytes = 0;
+        target_bytes = 0;
+        tmp = (unsigned char *) &desc;
+        // descriptor structure first
+        if (sizeof(hal_ipc_processor_desc_t) > max_size) {
+            while (target_bytes < sizeof(hal_ipc_processor_desc_t)) {
+                if (((nbytes = recv(cli_sock, tmp, (sizeof(hal_ipc_processor_desc_t) - target_bytes > max_size) ? max_size : (sizeof(hal_ipc_processor_desc_t) - target_bytes), 0)) == -1) || (nbytes == 0)) {
+                    hal_wifi_print("%s:%d:receiving command response failed err: %d data len:%d\n", __func__, __LINE__, errno, nbytes);
+                    close(cli_sock);
+                    break_cycle = 1;
+                    break;
+                }
+                tmp += nbytes;
+                target_bytes += nbytes;
+            }
+            if (break_cycle) {
+                continue;
+            }
+            nbytes = target_bytes;
+        } else if (((nbytes = recv(cli_sock, (unsigned char *) &desc, sizeof(hal_ipc_processor_desc_t), 0)) == -1) || (nbytes == 0)) {
+            hal_wifi_print("%s:%d:receiving command response failed err: %d data len:%d\n", __func__, __LINE__, errno, nbytes);
+            close(cli_sock);
+            continue;
+        }
+
+        //assert(target_bytes == desc.len);
+        hal_wifi_print("%s:%d: Descriptor %s received OK.\n", __func__, __LINE__, desc.name);
+
+        target_bytes = 0;
+
+        // check if there is more data to be received
+        if (desc.len > sizeof(hal_ipc_processor_desc_t)) {
+            //assert(desc.scratch_buf_size == (desc.len - sizeof(hal_ipc_processor_desc_t)));
+
+            desc.scratch_buf = malloc(desc.scratch_buf_size);
+            if (!desc.scratch_buf) {
+                hal_wifi_print("%s:%d: FAILED to allocate %d bytes for scratch buf of desc %s.\n", __func__, __LINE__, desc.scratch_buf_size, desc.name);
+                close(cli_sock);
+                continue;
+            }
+            memset(desc.scratch_buf, 0, desc.scratch_buf_size);
+            tmp = desc.scratch_buf;
+
+            nbytes = 0;
+
+            if (desc.scratch_buf_size > max_size) {
+                while (target_bytes < desc.scratch_buf_size) {
+                    if (((nbytes = recv(cli_sock, (unsigned char *)tmp, (desc.scratch_buf_size - target_bytes) > max_size ? max_size : (desc.scratch_buf_size - target_bytes), 0)) == -1) || (nbytes == 0)) {
+                        hal_wifi_print("%s:%d:receiving desc scratch buf in chunks failed err: %d data len:%d\n", __func__, __LINE__, errno, nbytes);
+                        free(desc.scratch_buf);
+                        close(cli_sock);
+                        break_cycle = 1;
+                        break;
+                    }
+                    tmp += nbytes;
+                    target_bytes += nbytes;
+                }
+                if (break_cycle) {
+                    continue;
+                }
+                nbytes = target_bytes;
+            } else if (((nbytes = recv(cli_sock, (unsigned char *)tmp, desc.scratch_buf_size, 0)) == -1) || (nbytes == 0)) {
+                hal_wifi_print("%s:%d:receiving command response failed err: %d data len:%d\n", __func__, __LINE__, errno, nbytes);
+                free(desc.scratch_buf);
+                close(cli_sock);
+                continue;
+            }
+        }
+
+        //assert(nbytes == desc.len);
+        hal_wifi_print("%s:%d: Descriptor %s notification data size checked OK. Executing...\n", __func__, __LINE__, desc.name);
+
+        // Execute notification server processor
+        serv_processor = client_processor_desc[desc.type].ipc_processor[processor_type_ipc_server_notification_output];
+        if ((serv_processor != NULL) && (serv_processor(&desc, NULL, NULL, NULL, NULL, NULL) != 0)) {
+            hal_wifi_print("%s:%d: Execution failed: %s\n", __func__, __LINE__, desc.name);
+
+            // indicate ipc failure
+            desc.ret = -1;
+            desc.len = sizeof(hal_ipc_processor_desc_t);
+            // free memory if allocated
+            if (desc.len > sizeof(hal_ipc_processor_desc_t)) {
+                free(desc.scratch_buf);
+            }
+        }
+
+        ///**************************************************************************************///
+        //                  SEND DESCRIPTOR BACK TO CLIENT                                       ///
+        ///**************************************************************************************///
+        //if (desc.len > max_size) {
+        //    nbytes = 0;
+        //    target_bytes = 0;
+
+        //    tmp = (unsigned char *) &desc;
+
+        //    while (target_bytes < desc.len) {
+        //        if ((nbytes = send(cli_sock, tmp, ((desc.len - target_bytes) > max_size) ? max_size : (desc.len - target_bytes), 0)) == -1) {
+        //            hal_wifi_print("%s:%d:sending desc in chunks failed err: %d\n", __func__, __LINE__, errno);
+        //            close(cli_sock);
+        //            // free memory if allocated
+        //            if (desc.len > sizeof(hal_ipc_processor_desc_t)) {
+        //                free(desc.scratch_buf);
+        //            }
+        //            break_cycle = 1;
+        //            break;
+        //        }
+        //        tmp += nbytes;
+        //        target_bytes += nbytes;
+        //    }
+        //    if (break_cycle) {
+        //        continue;
+        //    }
+        //    nbytes = target_bytes;
+        //} else if ((nbytes = send(cli_sock, (unsigned char *)&desc, desc.len, 0)) == -1) {
+        //    hal_wifi_print("%s:%d:sending desc failed err: %d\n", __func__, __LINE__, errno);
+        //    close(cli_sock);
+        //    // free memory if allocated
+        //    if (desc.len > sizeof(hal_ipc_processor_desc_t)) {
+        //        free(desc.scratch_buf);
+        //    }
+        //    continue;
+        //}
+
+        // on successful notification processing
+        // free memory if allocated
+        if (desc.len > sizeof(hal_ipc_processor_desc_t)) {
+            free(desc.scratch_buf);
+        }
+        close(cli_sock);
+    }
+
+    close(p_ipc_node->srv_sock);
+
+    hal_wifi_print("%s:%d: Stopping notification server.\n", __func__, __LINE__);
+    g_notification_server_started = false;
+
+    return NULL;
+}
+
+//--------------------------------------------------------------------------------------------------
+hal_ipc_node_t *client_create_hal_ipc_node(hal_ipc_node_type_t type)
+{
+    hal_ipc_node_t *node;
+
+    // always return the node based on enumeration of node type which is also the index of the array
+    node = &g_ipc_node[type];
+
+    node->type = type;
+
+    switch (type) {
+        case hal_ipc_node_type_notification_server:
+            strcpy(node->node_path, "/tmp/hal_notification_server");
+            break;
+
+        case hal_ipc_node_type_sync_call_sm_client:
+            strcpy(node->node_path, "/tmp/hal_sync_sm_client");
+            break;
+
+        case hal_ipc_node_type_sync_call_bm_client:
+            strcpy(node->node_path, "/tmp/hal_sync_bm_client");
+            break;
+
+        case hal_ipc_node_type_sync_call_server:
+        case hal_ipc_node_type_notification_client:
+        default:
+            return NULL;
+    }
+
+    if (type == hal_ipc_node_type_notification_server)
+    {
+        if (g_notification_server_started){
+            hal_wifi_print("%s:%d: Notification server already started.\n", __func__, __LINE__);
+        } else {
+            hal_wifi_print("%s:%d: Starting notification server.\n", __func__, __LINE__);
+            g_notification_server_started = true;
+            if (pthread_create(&node->listener_tid, NULL, hal_notification_server_func, node) != 0){
+                hal_wifi_print("%s:%d: Failed to create ipc node\n", __func__, __LINE__);
+                return NULL;
+            }
+        }
+    }
+
+    return node;
+}
diff --git wifi/hal_ipc/client/client_hal_ipc_core.h wifi/hal_ipc/client/client_hal_ipc_core.h
new file mode 100644
index 0000000..95913f0
--- /dev/null
+++ wifi/hal_ipc/client/client_hal_ipc_core.h
@@ -0,0 +1,545 @@
+#ifndef CLIENT_HAL_IPC_H
+#define CLIENT_HAL_IPC_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <pthread.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include "wifi_hal.h"
+
+#define MAX_IPC_BUFF            10240
+#define MAX_HAL_IPC_PROTO_BUFF  50*MAX_IPC_BUFF
+
+typedef enum {
+    processor_type_ipc_client_input,
+    processor_type_ipc_client_output,
+    processor_type_ipc_server_output,
+    processor_type_ipc_client_notification_input,
+    processor_type_ipc_server_notification_output,
+    processor_type_ipc_max
+} hal_ipc_processor_type_t;
+
+struct hal_ipc_processor_desc;
+
+typedef int (*hal_ipc_processor_t)(struct hal_ipc_processor_desc *desc, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5);
+
+typedef enum {
+    hal_ipc_node_type_notification_server,
+    hal_ipc_node_type_notification_client,
+    hal_ipc_node_type_sync_call_server,
+    hal_ipc_node_type_sync_call_sm_client,
+    hal_ipc_node_type_sync_call_bm_client,
+    hal_ipc_node_type_max
+} hal_ipc_node_type_t;
+
+typedef enum {
+    hal_ipc_desc_type_set_radio_stats_enable,               // INT wifi_setRadioStatsEnable(INT radioIndex, BOOL enabled);
+    hal_ipc_desc_type_get_ssid_num_of_entries,              // INT wifi_getSSIDNumberOfEntries(ULONG *numEntries);
+    hal_ipc_desc_type_get_ap_assoc_dev_stats,               // INT wifi_getApAssociatedDeviceStats(INT apIndex, mac_address_t *clientMacAddress, wifi_associated_dev_stats_t *associated_dev_stats, ULLONG *handle);
+    hal_ipc_desc_type_get_radio_chan_stats,                 // INT wifi_getRadioChannelStats(INT radioIndex, wifi_channelStats_t *input_output_channelStats_array, INT array_size);
+    hal_ipc_desc_type_start_neighbor_scan,                  // INT wifi_startNeighborScan(INT apIndex, wifi_neighborScanMode_t scan_mode, INT dwell_time, UINT chan_num, UINT *chan_list);
+    hal_ipc_desc_type_get_neighbor_wifi_status,             // INT wifi_getNeighboringWiFiStatus(INT radioIndex, wifi_neighbor_ap2_t **neighbor_ap_array, UINT *output_array_size);
+    hal_ipc_desc_type_get_ssid_traffic_stats2,              // INT wifi_getSSIDTrafficStats2(INT ssidIndex, wifi_ssidTrafficStats2_t *output_struct);
+    hal_ipc_desc_type_get_ap_assoc_dev_rx_stats_result,     // INT wifi_getApAssociatedDeviceRxStatsResult(INT radioIndex, mac_address_t *clientMacAddress, wifi_associated_dev_rate_info_rx_stats_t **stats_array, UINT *output_array_size, ULLONG *handle);
+    hal_ipc_desc_type_get_ssid_enable,                      // INT wifi_getSSIDEnable(INT ssidIndex, BOOL *output_bool);
+    hal_ipc_desc_type_get_ssid_radio_index,                 // INT wifi_getSSIDRadioIndex(INT ssidIndex, INT *radioIndex);
+    hal_ipc_desc_type_get_ssid_name_status,                 // INT wifi_getSSIDNameStatus(INT apIndex, CHAR *output_string);
+    hal_ipc_desc_type_get_ap_name,                          // INT wifi_getApName(INT apIndex, CHAR *output_string);
+    hal_ipc_desc_type_get_neighbor_report_activation,       // INT wifi_getNeighborReportActivation(UINT apIndex, BOOL *activate);
+    hal_ipc_desc_type_get_bss_transition_activation,        // INT wifi_getBSSTransitionActivation(UINT apIndex, BOOL *activate);
+    hal_ipc_desc_type_get_ap_assoc_dev_diag_result3,        // INT wifi_getApAssociatedDeviceDiagnosticResult3(INT apIndex, wifi_associated_dev3_t **associated_dev_array, UINT *output_array_size);
+    hal_ipc_desc_type_get_ap_assoc_client_diag_result,      // INT wifi_getApAssociatedClientDiagnosticResult(INT apIndex, char *mac_addr, wifi_associated_dev3_t *dev_conn);
+    hal_ipc_desc_type_get_radio_operating_freq_band,        // INT wifi_getRadioOperatingFrequencyBand(INT radioIndex, CHAR *output_string);
+    hal_ipc_desc_type_get_radio_num_of_entries,             // INT wifi_getRadioNumberOfEntries(ULONG *output);
+    hal_ipc_desc_type_get_ap_assoc_dev_tx_stats_result,     // INT wifi_getApAssociatedDeviceTxStatsResult(INT radioIndex, mac_address_t *clientMacAddress, wifi_associated_dev_rate_info_tx_stats_t **stats_array, UINT *output_array_size, ULLONG *handle);
+    hal_ipc_desc_type_steering_set_group,                   // INT wifi_steering_setGroup(UINT steeringgroupIndex, wifi_steering_apConfig_t *cfg_2, wifi_steering_apConfig_t *cfg_5);
+    hal_ipc_desc_type_steering_client_set,                  // INT wifi_steering_clientSet(UINT steeringgroupIndex, INT apIndex, mac_address_t client_mac, wifi_steering_clientConfig_t *config);
+    hal_ipc_desc_type_steering_client_remove,               // INT wifi_steering_clientRemove(UINT steeringgroupIndex, INT apIndex, mac_address_t client_mac);
+    hal_ipc_desc_type_steering_client_disconnect,           // INT wifi_steering_clientDisconnect(UINT steeringgroupIndex, INT apIndex, mac_address_t client_mac, wifi_disconnectType_t type, UINT reason);
+    hal_ipc_desc_type_set_btm_request,                      // INT wifi_setBTMRequest(UINT apIndex, CHAR *peerMac, wifi_BTMRequest_t *request);
+    hal_ipc_desc_type_get_ssid_name,                        // INT wifi_getSSIDName(INT apIndex, CHAR *output_string);
+    hal_ipc_desc_type_set_rm_beacon_request,                // INT wifi_setRMBeaconRequest(UINT apIndex, CHAR *peer, wifi_BeaconRequest_t *in_request, UCHAR *out_DialogToken);
+    hal_ipc_desc_type_get_association_req_ies,              // INT wifi_getAssociationReqIEs(UINT apIndex, const mac_address_t *clientMacAddress, CHAR *req_ies, UINT req_ies_size, UINT *req_ies_len);
+    hal_ipc_desc_type_set_neighbor_reports,                 // INT wifi_setNeighborReports(UINT apIndex, UINT numNeighborReports, wifi_NeighborReport_t *neighborReports);
+    hal_ipc_desc_type_set_neighbor_report_activation,       // INT wifi_setNeighborReportActivation(UINT apIndex, BOOL activate);
+    hal_ipc_desc_type_get_radio_if_name,                    // INT wifi_getRadioIfName(INT radioIndex, CHAR *output_string);
+    hal_ipc_desc_type_get_ap_num_assoc_devs,                // INT wifi_getApNumDevicesAssociated(INT apIndex, ULONG *output_ulong);
+
+    hal_ipc_desc_type_steering_unregister,                  // INT wifi_steering_eventUnregister(void);
+    hal_ipc_desc_type_steering_register,                    // INT wifi_steering_eventRegister(wifi_steering_eventCB_t event_cb);
+    hal_ipc_desc_type_steering_event,                       // notify about steering event
+    hal_ipc_desc_type_mgmt_frame_callback_register,         // INT wifi_mgmt_frame_callbacks_register(wifi_receivedMgmtFrame_callback mgmtRxCallback);
+    hal_ipc_desc_type_mgmt_frame_event,                     // notify about mgmt frame event
+    hal_ipc_rm_beacon_request_register,                     // INT wifi_RMBeaconRequestCallbackRegister(unsigned int apIndex, wifi_RMBeaconReport_callback cb_fn)
+    hal_ipc_rm_beacon_report_event,                        // notify about RM beacon request event
+    hal_ipc_btm_query_request_register,                     // INT wifi_BTMQueryRequest_callback_register(unsigned int apIndex, wifi_BTMQueryRequest_callback btmQueryCallback, wifi_BTMResponse_callback btmResponseCallback)
+    hal_ipc_btm_query_request_event,                        // notify about BTM query request event
+    hal_ipc_btm_response_event,                             // notify about BTM response event
+    hal_ipc_desc_type_max
+} hal_ipc_desc_type_t;
+
+#define HAL_IPC_RADIO_CHANNELS_MAX          64  // NOT SURE ABOUT THIS VALUE - NEED TO BE CLARIFIED!
+#define HAL_IPC_MAX_STA_SUPPORT_NUM         16  //64  // OneWifi monitor.h #define MAX_ASSOCIATED_WIFI_DEVS    64
+
+#define HAL_IPC_MAX_NEIGHBOR_AP_COUNT       16
+#define HAL_IPC_MAX_STATS_ARRAY_NUM         HAL_IPC_MAX_STA_SUPPORT_NUM
+#define HAL_IPC_MAX_STRING_LEN              64
+
+#define HAL_IPC_MAC_ADDR_SIZE_BYTES         6
+#define HAL_IPC_ASSOC_REQ_IES_BUF_SIZE      1024 // Magic number hardcoded in bsal.c function target_bsal_client_info
+#define HAL_IPC_ACL_DEVS_LIST_STRING_LEN    512
+
+#define HAL_IPC_DESCRIPTOR_NAME_LEN 128
+
+#pragma pack(1)
+typedef struct hal_ipc_processor_desc {
+    hal_ipc_desc_type_t type;
+    char                name[HAL_IPC_DESCRIPTOR_NAME_LEN];
+    hal_ipc_processor_t ipc_processor[processor_type_ipc_max];
+    unsigned int        len;
+    int                 ret;
+    union {
+        int init_data;
+        //----------------------------------------------------------------------
+        // wifi_setRadioStatsEnable
+        struct {
+            INT radio_index;
+            BOOL enabled;
+        } set_radio_stats_enable;
+        //----------------------------------------------------------------------
+        // wifi_getApAssociatedDeviceStats
+        struct {
+            INT ap_index;
+            mac_address_t client_mac_addr;
+        } get_ap_assoc_dev_stats;
+        //----------------------------------------------------------------------
+        // wifi_getRadioChannelStats
+        struct {
+            INT radio_index;
+            wifi_channelStats_t input_output_channel_stats_array[0];            // HAL_IPC_RADIO_CHANNELS_MAX
+            INT array_size;
+        } get_radio_channel_stats;
+        //----------------------------------------------------------------------
+        // wifi_startNeighborScan
+        struct {
+            INT ap_index;
+            wifi_neighborScanMode_t scan_mode;
+            INT dwell_time;
+            UINT chan_num;
+        } start_neighbor_scan;
+        //----------------------------------------------------------------------
+        // wifi_getNeighboringWiFiStatus
+        struct {
+            INT radio_index;
+        } get_neighbor_wifi_status;
+        //----------------------------------------------------------------------
+        // wifi_getSSIDTrafficStats2
+        struct {
+            INT ssid_index;
+        } get_ssid_traffic_stats2;
+        //----------------------------------------------------------------------
+        // wifi_getApAssociatedDeviceRxStatsResult
+        struct {
+            INT radio_index;
+            mac_address_t client_mac_addr;
+        } get_ap_assoc_dev_rx_stats_result;
+        //----------------------------------------------------------------------
+        // wifi_getSSIDEnable
+        struct {
+            INT ssid_index;
+        } get_ssid_enable;
+        //----------------------------------------------------------------------
+        // wifi_getSSIDRadioIndex
+        struct {
+            INT ssid_index;
+        } get_ssid_radio_index;
+        //----------------------------------------------------------------------
+        // wifi_getSSIDNameStatus
+        struct {
+            INT ap_index;
+        } get_ssid_name_status;
+        //----------------------------------------------------------------------
+        // wifi_getApName
+        struct {
+            INT ap_index;
+        } get_ap_name;
+        //----------------------------------------------------------------------
+        // wifi_getNeighborReportActivation
+        struct {
+            UINT ap_index;
+        } get_neighbor_report_activation;
+        //----------------------------------------------------------------------
+        // wifi_getBSSTransitionActivation
+        struct {
+            UINT ap_index;
+        } get_bss_transition_activation;
+        //----------------------------------------------------------------------
+        // wifi_getApAssociatedDeviceDiagnosticResult3
+        struct {
+            UINT ap_index;
+        } get_ap_assoc_dev_diag_result3;
+        //----------------------------------------------------------------------
+        // wifi_getApAssociatedClientDiagnosticResult
+        struct {
+            INT ap_index;
+            char mac_addr[HAL_IPC_MAC_ADDR_SIZE_BYTES];
+        } get_ap_assoc_client_diag_result;
+        //----------------------------------------------------------------------
+        // wifi_getRadioOperatingFrequencyBand
+        struct {
+             INT radio_index;
+        } get_radio_operating_freq_band;
+        //----------------------------------------------------------------------
+        // steering event data
+        struct {
+            unsigned int steering_group_index;
+            wifi_steering_event_t evt;
+        } steering_event_data;
+        //----------------------------------------------------------------------
+        // mgmt frame event data
+        struct {
+            INT apIndex;
+            UCHAR sta_mac[HAL_IPC_MAC_ADDR_SIZE_BYTES];
+            UCHAR frame[0];
+            UINT len;
+            wifi_mgmtFrameType_t type;
+            wifi_direction_t dir;
+        } mgmt_frame_event_data;
+        //----------------------------------------------------------------------
+        // RM beacon report event data
+        // wifi_RMBeaconReport_callback parameters
+        struct {
+            UINT                apIndex;
+            wifi_BeaconReport_t out_struct[0];
+            UINT                out_array_size;
+            UCHAR               out_DialogToken;
+        } rm_beacon_report_event_data;
+        //----------------------------------------------------------------------
+        // BTM query request event data
+        struct {
+            UINT                apIndex;
+            mac_address_t       peerMac;
+            wifi_BTMQuery_t     query[0];
+            UINT                inMemSize;
+            wifi_BTMRequest_t   request[0];
+        } btm_query_request_event_data;
+        //----------------------------------------------------------------------
+        // BTM response event data
+        struct {
+            UINT                apIndex;
+            mac_address_t       peerMac;
+            wifi_BTMResponse_t  response;
+        } btm_response_event_data;
+        //----------------------------------------------------------------------
+        // wifi_getApAssociatedDeviceTxStatsResult
+        struct {
+            INT radio_index;
+            mac_address_t client_mac_addr;
+        } get_ap_assoc_dev_tx_stats_result;
+        //----------------------------------------------------------------------
+        // wifi_steering_setGroup
+        struct {
+            UINT steering_group_index;
+            wifi_steering_apConfig_t cfg_2;
+            wifi_steering_apConfig_t cfg_5;
+        } set_steering_group;
+        //----------------------------------------------------------------------
+        // wifi_steering_clientSet
+        struct {
+            UINT steering_group_index;
+            INT ap_index;
+            mac_address_t client_mac;
+            wifi_steering_clientConfig_t config;
+        } set_steering_client;
+        //----------------------------------------------------------------------
+        // wifi_steering_clientRemove
+        struct {
+            UINT steering_group_index;
+            INT ap_index;
+            mac_address_t client_mac;
+        } remove_steering_client;
+        //----------------------------------------------------------------------
+        // wifi_steering_clientDisconnect
+        struct {
+            UINT steering_group_index;
+            INT ap_index;
+            mac_address_t client_mac;
+            wifi_disconnectType_t type;
+            UINT reason;
+        } disconnect_steering_client;
+        //----------------------------------------------------------------------
+        // wifi_setBTMRequest
+        struct {
+            UINT ap_index;
+            mac_address_t peer_mac;
+            wifi_BTMRequest_t request;
+        } set_btm_request;
+        //----------------------------------------------------------------------
+        // wifi_getSSIDName
+        struct {
+            INT ap_index;
+        } get_ssid_name;
+        //----------------------------------------------------------------------
+        // wifi_setRMBeaconRequest
+        struct {
+            UINT ap_index;
+            mac_address_t peer_mac;
+            wifi_BeaconRequest_t in_request;
+        } set_rm_beacon_request;
+        //----------------------------------------------------------------------
+        // wifi_getAssociationReqIEs
+        struct {
+            UINT ap_index;
+            mac_address_t client_mac_addr;
+            UINT req_ies_size;
+        } get_association_req_ies;
+        //----------------------------------------------------------------------
+        // wifi_setNeighborReports
+        struct {
+            UINT ap_index;
+            UINT num_neighbor_reports;
+            wifi_NeighborReport_t neighbor_reports[0];                          // HAL_IPC_MAX_NEIGHBOR_AP_COUNT
+        } set_neighbor_reports;
+        //----------------------------------------------------------------------
+        // wifi_setNeighborReportActivation
+        struct {
+            UINT ap_index;
+            BOOL activate;
+        } set_neighbor_report_activation;
+        //----------------------------------------------------------------------
+        // wifi_getRadioIfName
+        struct {
+            INT radio_index;
+        } get_radio_if_name;
+        //----------------------------------------------------------------------
+        // wifi_getApNumDevicesAssociated
+        struct {
+            INT ap_index;
+        } get_ap_num_assoc_devs;
+        //----------------------------------------------------------------------
+        // ****** end of "in" union ******
+    } in;
+
+    union {
+        int init_data;
+        //----------------------------------------------------------------------
+        // wifi_getSSIDNumberOfEntries
+        struct {
+            ULONG numEntries;
+        } get_ssid_num_entries;
+        //----------------------------------------------------------------------
+        // wifi_getApAssociatedDeviceStats
+        struct {
+            wifi_associated_dev_stats_t associated_dev_stats;
+            ULLONG handle;                                                      // assoc_count
+        } get_ap_assoc_dev_stats;
+        //----------------------------------------------------------------------
+        // wifi_getRadioChannelStats
+        struct {
+            wifi_channelStats_t input_output_channel_stats_array[0];            // HAL_IPC_RADIO_CHANNELS_MAX
+        } get_radio_channel_stats;
+        //----------------------------------------------------------------------
+        // wifi_startNeighborScan
+        struct {
+            UINT chan_list;
+        } start_neighbor_scan;
+        //----------------------------------------------------------------------
+        // wifi_getNeighboringWiFiStatus
+        struct {
+            wifi_neighbor_ap2_t neighbor_ap_array[0];                           // HAL_IPC_MAX_NEIGHBOR_AP_COUNT
+            UINT output_array_size;
+        } get_neighbor_wifi_status;
+        //----------------------------------------------------------------------
+        // wifi_getSSIDTrafficStats2
+        struct {
+            wifi_ssidTrafficStats2_t output_struct;
+        } get_ssid_traffic_stats2;
+        //----------------------------------------------------------------------
+        // wifi_getApAssociatedDeviceRxStatsResult
+        struct {
+            wifi_associated_dev_rate_info_rx_stats_t stats_array[0];            // HAL_IPC_MAX_STATS_ARRAY_NUM
+            UINT output_array_size;
+            ULLONG handle;
+        } get_ap_assoc_dev_rx_stats_result;
+        //----------------------------------------------------------------------
+        // wifi_getSSIDEnable
+        struct {
+            BOOL output_bool;
+        } get_ssid_enable;
+        //----------------------------------------------------------------------
+        // wifi_getSSIDRadioIndex
+        struct {
+            INT radio_index;
+        } get_ssid_radio_index;
+        //----------------------------------------------------------------------
+        // wifi_getSSIDNameStatus
+        struct {
+            CHAR output_string[HAL_IPC_MAX_STRING_LEN];
+        } get_ssid_name_status;
+        //----------------------------------------------------------------------
+        // wifi_getApName
+        struct {
+            CHAR output_string[HAL_IPC_MAX_STRING_LEN];
+        } get_ap_name;
+        //----------------------------------------------------------------------
+        // wifi_getNeighborReportActivation
+        struct {
+            BOOL activate;
+        } get_neighbor_report_activation;
+        //----------------------------------------------------------------------
+        // wifi_getBSSTransitionActivation
+        struct {
+            BOOL activate;
+        } get_bss_transition_activation;
+        //----------------------------------------------------------------------
+        // wifi_getApAssociatedDeviceDiagnosticResult3
+        struct {
+            wifi_associated_dev3_t  dev[0];                                     // HAL_IPC_MAX_STA_SUPPORT_NUM
+            unsigned int num;
+        } get_ap_assoc_dev_diag_result3;
+        //----------------------------------------------------------------------
+        // wifi_getApAssociatedClientDiagnosticResult
+        struct {
+            wifi_associated_dev3_t dev_conn;
+        } get_ap_assoc_client_diag_result;
+        //----------------------------------------------------------------------
+        // wifi_getRadioOperatingFrequencyBand
+        struct {
+             CHAR output_string[HAL_IPC_MAX_STRING_LEN];
+        } get_radio_operating_freq_band;
+        //----------------------------------------------------------------------
+        // wifi_getRadioNumberOfEntries
+        struct {
+            ULONG output;
+        } get_radio_number_of_entries;
+        //----------------------------------------------------------------------
+        // wifi_getApAssociatedDeviceTxStatsResult
+        struct {
+            wifi_associated_dev_rate_info_tx_stats_t stats_array[0];            // HAL_IPC_MAX_STATS_ARRAY_NUM
+            UINT output_array_size;
+            ULLONG handle;
+        } get_ap_assoc_dev_tx_stats_result;
+        //----------------------------------------------------------------------
+        // wifi_steering_setGroup
+        struct {
+            wifi_steering_apConfig_t cfg_2;
+            wifi_steering_apConfig_t cfg_5;
+        } set_steering_group;
+        //----------------------------------------------------------------------
+        // wifi_steering_clientSet
+        struct {
+            wifi_steering_clientConfig_t config;
+        } set_steering_client;
+        //----------------------------------------------------------------------
+        // wifi_steering_clientRemove
+        //struct {
+        //          *** no return data except return code is expected ***
+        //} remove_steering_client;
+        //----------------------------------------------------------------------
+        // wifi_steering_clientDisconnect
+        //struct {
+        //          *** no return data except return code is expected ***
+        //} disconnect_steering_client;
+        //----------------------------------------------------------------------
+        // wifi_setBTMRequest
+        //struct {
+        //          *** no return data except return code is expected ***
+        //} set_btm_request;
+        //----------------------------------------------------------------------
+        // wifi_getSSIDName
+        struct {
+            CHAR output_string[HAL_IPC_MAX_STRING_LEN];
+        } get_ssid_name;
+        //----------------------------------------------------------------------
+        // wifi_setRMBeaconRequest
+        struct {
+            UCHAR dialog_token;
+        } set_rm_beacon_request;
+        //----------------------------------------------------------------------
+        // wifi_getAssociationReqIEs
+        struct {
+            CHAR req_ies[HAL_IPC_ASSOC_REQ_IES_BUF_SIZE];
+            UINT req_ies_len;
+        } get_association_req_ies;
+        //----------------------------------------------------------------------
+        // wifi_setNeighborReports
+        //struct {
+        //          *** no return data except return code is expected ***
+        //} set_neighbor_reports;
+        //----------------------------------------------------------------------
+        // wifi_setNeighborReportActivation
+        //struct {
+        //          *** no return data except return code is expected ***
+        //} set_neighbor_report_activation;
+        //----------------------------------------------------------------------
+        // wifi_getRadioIfName
+        struct {
+            CHAR output_string[HAL_IPC_MAX_STRING_LEN];
+        } get_radio_if_name;
+        //----------------------------------------------------------------------
+        // wifi_getApNumDevicesAssociated
+        struct {
+            ULONG output;
+        } get_ap_num_assoc_devs;
+        //----------------------------------------------------------------------
+        // ****** end of "out" union ******
+    } out;
+    // internal use of descriptor to allocate big buffers
+    unsigned char *scratch_buf;
+    unsigned int scratch_buf_size;
+} __attribute__((packed, aligned(1))) hal_ipc_processor_desc_t;
+
+typedef struct {
+    char                node_path[64];
+    pthread_t           listener_tid;
+    int                 srv_sock;
+    struct sockaddr_un  srv_sockaddr;
+    hal_ipc_node_type_t	type;
+} hal_ipc_node_t;
+
+//--------------------------------------------------------------------------------------------------
+void hal_wifi_print(const char *format, ...);
+
+//--------------------------------------------------------------------------------------------------
+hal_ipc_node_t              *client_create_hal_ipc_node(hal_ipc_node_type_t type);
+hal_ipc_processor_desc_t    *client_get_processor_desc(hal_ipc_desc_type_t type);
+int                         hal_ipc_exec(hal_ipc_node_t *p_ipc_node, hal_ipc_processor_desc_t *arg);
+
+//--------------------------------------------------------------------------------------------------
+int	ipc_input_client(struct hal_ipc_processor_desc *desc, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5);
+int	ipc_output_client(struct hal_ipc_processor_desc *desc, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5);
+
+//--------------------------------------------------------------------------------------------------
+int server_ipc_notification_output(struct hal_ipc_processor_desc *desc, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5);
+
+//--------------------------------------------------------------------------------------------------
+void hal_ipc_set_client_steering_callback(wifi_steering_eventCB_t client_steering_event_callback);
+wifi_steering_eventCB_t     hal_ipc_get_client_steering_callback(void);
+
+//--------------------------------------------------------------------------------------------------
+void hal_ipc_set_client_rm_beacon_report_callback(unsigned int ap_index, wifi_RMBeaconReport_callback vap_cb_fn);
+wifi_RMBeaconReport_callback    hal_ipc_get_client_rm_beacon_report_callback(unsigned int ap_index);
+
+//--------------------------------------------------------------------------------------------------
+void hal_ipc_set_client_btm_query_request_callback(unsigned int ap_index,
+                                                wifi_BTMQueryRequest_callback btmQueryCallback,
+                                                wifi_BTMResponse_callback btmResponseCallback);
+wifi_BTMQueryRequest_callback   hal_ipc_get_btm_query_request_callback(unsigned int ap_index);
+wifi_BTMResponse_callback       hal_ipc_get_btm_response_callback(unsigned int ap_index);
+
+//--------------------------------------------------------------------------------------------------
+typedef int (* app_get_ap_assoc_dev_diag_res3_t)(int ap_index,
+                                                 wifi_associated_dev3_t **assoc_dev_array,
+                                                 unsigned int *output_array_size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // CLIENT_HAL_IPC_H
diff --git wifi/hal_ipc/client/client_hal_ipc_processors.c wifi/hal_ipc/client/client_hal_ipc_processors.c
new file mode 100644
index 0000000..e4771e1
--- /dev/null
+++ wifi/hal_ipc/client/client_hal_ipc_processors.c
@@ -0,0 +1,1055 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include "client_hal_ipc_core.h"
+
+//--------------------------------------------------------------------------------------------------
+int ipc_input_client(struct hal_ipc_processor_desc *desc,
+                     void *arg1,
+                     void *arg2,
+                     void *arg3,
+                     void *arg4,
+                     void *arg5)
+{
+    hal_wifi_print("%s:%d Enter: handled client input parameters for %s\n", __func__, __LINE__, desc->name);
+    mac_address_t sta_mac;
+    memset(sta_mac, 0, sizeof(mac_address_t));
+
+    desc->len = sizeof(hal_ipc_processor_desc_t);
+    desc->scratch_buf = NULL;
+    desc->scratch_buf_size = 0;
+
+    switch (desc->type) {
+        case hal_ipc_desc_type_set_radio_stats_enable:
+            if (!arg1 || !arg2) {
+                hal_wifi_print("%s:%d for RFC API function %s require 2 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.set_radio_stats_enable.radio_index = *(INT*) arg1;
+            desc->in.set_radio_stats_enable.enabled = *(BOOL*) arg2;
+            break;
+
+        case hal_ipc_desc_type_get_ssid_num_of_entries:
+            // do nothing. The argument for execure RFC API is pointer - will be processed in ipc_client_ouput func
+            break;
+
+        case hal_ipc_desc_type_get_ap_assoc_dev_stats:
+            if (!arg1 || !arg2) {
+                hal_wifi_print("%s:%d for RFC API %s function require 2 input arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_ap_assoc_dev_stats.ap_index = *(INT*) arg1;
+            if (!memcpy((unsigned char*) &desc->in.get_ap_assoc_dev_stats.client_mac_addr[0],
+                       (unsigned char*) arg2, sizeof(mac_address_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for client_mac_addr.\n", __func__, __LINE__);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_get_radio_chan_stats:
+            if (!arg1 || !arg2 || !arg3) {
+                hal_wifi_print("%s:%d for RFC API %s function require 3 input arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_radio_channel_stats.radio_index = *(INT*) arg1;
+            desc->in.get_radio_channel_stats.array_size = *(INT*) arg3;
+            int stats_num = desc->in.get_radio_channel_stats.array_size;
+
+            if (desc->in.get_radio_channel_stats.array_size > HAL_IPC_RADIO_CHANNELS_MAX) {
+                hal_wifi_print("%s:%d FAIL %s input parameter array_size too big.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            desc->scratch_buf = (unsigned char*) malloc(stats_num * sizeof(wifi_channelStats_t));
+
+            if (!desc->scratch_buf) {
+                hal_wifi_print("%s:%d FAIL to allocate memory for %d wifi_channelStats_t elements.\n", __func__, __LINE__, stats_num);
+                return -1;
+            }
+
+            desc->scratch_buf_size = stats_num * sizeof(wifi_channelStats_t);
+            memset(desc->scratch_buf, 0, desc->scratch_buf_size);
+
+            if (!memcpy(desc->scratch_buf, (unsigned char*) arg2, desc->scratch_buf_size)) {
+                hal_wifi_print("%s:%d FAIL memcpy for input_output_channel_stats_array.\n", __func__, __LINE__);
+                free(desc->scratch_buf);
+                return -1;
+            }
+
+            desc->len += desc->scratch_buf_size;
+            break;
+
+        case hal_ipc_desc_type_start_neighbor_scan:
+            if (!arg1 || !arg2 || !arg3 || !arg4) {
+                hal_wifi_print("%s:%d for RFC API %s function require 4 input arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            desc->in.start_neighbor_scan.ap_index = *(INT*) arg1;
+            desc->in.start_neighbor_scan.scan_mode = *(wifi_neighborScanMode_t*) arg2;
+            desc->in.start_neighbor_scan.dwell_time = *(INT*) arg3;
+            desc->in.start_neighbor_scan.chan_num = *(UINT*) arg4;
+            break;
+
+        case hal_ipc_desc_type_get_neighbor_wifi_status:
+            if (!arg1) {
+                hal_wifi_print("%s:%d for RFC API %s function require 1 input argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_neighbor_wifi_status.radio_index = *(INT*) arg1;
+            break;
+
+        case hal_ipc_desc_type_get_ssid_traffic_stats2:
+            if (!arg1) {
+                hal_wifi_print("%s:%d for RFC API %s function require 1 input argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_ssid_traffic_stats2.ssid_index = *(INT*) arg1;
+            break;
+
+        case hal_ipc_desc_type_get_ap_assoc_dev_rx_stats_result:
+            if (!arg1 || !arg2) {
+                hal_wifi_print("%s:%d for RFC API %s function require 2 input arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_ap_assoc_dev_rx_stats_result.radio_index = *(INT*) arg1;
+            if (!memcpy((unsigned char*) &desc->in.get_ap_assoc_dev_rx_stats_result.client_mac_addr[0],
+                      (unsigned char*) arg2,
+                      sizeof(mac_address_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s client_mac_addr.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_get_ssid_enable:
+            if (!arg1) {
+                hal_wifi_print("%s:%d for RFC API %s function require 1 input argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_ssid_enable.ssid_index = *(INT*) arg1;
+            break;
+
+        case hal_ipc_desc_type_get_ssid_radio_index:
+            if (!arg1) {
+                hal_wifi_print("%s:%d for RFC API %s function require 1 input argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_ssid_radio_index.ssid_index = *(INT*) arg1;
+            break;
+
+        case hal_ipc_desc_type_get_ssid_name_status:
+            if (!arg1) {
+                hal_wifi_print("%s:%d for RFC API %s function require 1 input argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_ssid_name_status.ap_index = *(INT*) arg1;
+            break;
+
+        case hal_ipc_desc_type_get_ap_name:
+            if (!arg1) {
+                hal_wifi_print("%s:%d for RFC API %s function require 1 input argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_ap_name.ap_index = *(INT*) arg1;
+            break;
+
+        case hal_ipc_desc_type_get_neighbor_report_activation:
+            if (!arg1) {
+                hal_wifi_print("%s:%d for RFC API %s function require 1 input argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_neighbor_report_activation.ap_index = *(UINT*) arg1;
+            break;
+
+        case hal_ipc_desc_type_get_bss_transition_activation:
+            if (!arg1) {
+                hal_wifi_print("%s:%d for RFC API %s function require 1 input argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_bss_transition_activation.ap_index = *(UINT*) arg1;
+            break;
+
+        case hal_ipc_desc_type_get_ap_assoc_dev_diag_result3:
+            if (!arg1) {
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_ap_assoc_dev_diag_result3.ap_index = *(unsigned int*) arg1;
+            break;
+
+        case hal_ipc_desc_type_get_ap_assoc_client_diag_result:
+            if (!arg1 || !arg2) {
+                hal_wifi_print("%s:%d for RFC API %s function require 2 input arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_ap_assoc_client_diag_result.ap_index = *(int*) arg1;
+            if (!memcpy((unsigned char*) &desc->in.get_ap_assoc_client_diag_result.mac_addr[0],
+                       (unsigned char*) arg2,
+                       HAL_IPC_MAC_ADDR_SIZE_BYTES)) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s mac_addr.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_get_radio_operating_freq_band:
+            if (!arg1) {
+                hal_wifi_print("%s:%d for RFC API %s function require 1 input argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_radio_operating_freq_band.radio_index = *(int*) arg1;
+            break;
+
+        case hal_ipc_desc_type_get_radio_num_of_entries:
+            hal_wifi_print("%s:%d No client input required. Continue processing.\n", __func__, __LINE__);
+            break;
+
+        case hal_ipc_desc_type_get_ap_assoc_dev_tx_stats_result:
+            if (!arg1 || !arg2) {
+                hal_wifi_print("%s:%d for RFC API function %s require 2 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            desc->in.get_ap_assoc_dev_tx_stats_result.radio_index = *(INT*) arg1;
+            if (!memcpy((unsigned char*) &desc->in.get_ap_assoc_dev_tx_stats_result.client_mac_addr[0],
+                      (unsigned char*) arg2,
+                      sizeof(mac_address_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s client_mac_addr.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_steering_set_group:
+            if (!arg1 || !arg2 || !arg3) {
+                hal_wifi_print("%s:%d for RFC API function %s require 3 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.set_steering_group.steering_group_index = *(INT*) arg1;
+            if (!memcpy((unsigned char*) &desc->in.set_steering_group.cfg_2,
+                      (unsigned char*) arg2,
+                      sizeof(wifi_steering_apConfig_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s client_mac_addr.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            if (!memcpy((unsigned char*) &desc->in.set_steering_group.cfg_5,
+                      (unsigned char*) arg3,
+                      sizeof(wifi_steering_apConfig_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s client_mac_addr.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_steering_client_set:
+            if (!arg1 || !arg2 || !arg3 || !arg4) {
+                hal_wifi_print("%s:%d for RFC API function %s require 4 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            desc->in.set_steering_client.steering_group_index = *(INT*) arg1;
+            desc->in.set_steering_client.ap_index = *(INT*) arg2;
+            if (!memcpy((unsigned char*) &desc->in.set_steering_client.client_mac[0],
+                      (unsigned char*) arg3,
+                      sizeof(mac_address_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s client_mac_addr.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            if (!memcpy((unsigned char*) &desc->in.set_steering_client.config,
+                      (unsigned char*) arg4,
+                      sizeof(wifi_steering_clientConfig_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s client_mac_addr.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_steering_client_remove:
+            if (!arg1 || !arg2 || !arg3) {
+                hal_wifi_print("%s:%d for RFC API function %s require 3 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            desc->in.remove_steering_client.steering_group_index = *(INT*) arg1;
+            desc->in.remove_steering_client.ap_index = *(INT*) arg2;
+            if (!memcpy((unsigned char*) &desc->in.remove_steering_client.client_mac[0],
+                      (unsigned char*) arg3,
+                      sizeof(mac_address_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s client_mac_addr.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            break;
+
+        case hal_ipc_desc_type_steering_client_disconnect:
+            if (!arg1 || !arg2 || !arg3 || !arg4 || !arg5) {
+                hal_wifi_print("%s:%d for RFC API function %s require 5 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            desc->in.disconnect_steering_client.steering_group_index = *(INT*) arg1;
+            desc->in.disconnect_steering_client.ap_index = *(INT*) arg2;
+            if (!memcpy((unsigned char*) &desc->in.disconnect_steering_client.client_mac[0],
+                      (unsigned char*) arg3,
+                      sizeof(mac_address_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s client_mac_addr.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.disconnect_steering_client.type = *(wifi_disconnectType_t*) arg4;
+            desc->in.disconnect_steering_client.reason = *(UINT*) arg5;
+            break;
+
+        case hal_ipc_desc_type_set_btm_request:
+            if (!arg1 || !arg2 || !arg3) {
+                hal_wifi_print("%s:%d for RFC API function %s require 3 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            desc->in.set_btm_request.ap_index = *(UINT*) arg1;
+
+            sscanf((char *)arg2, "%02x:%02x:%02x:%02x:%02x:%02x", &sta_mac[0], &sta_mac[1], &sta_mac[2],&sta_mac[3], &sta_mac[4], &sta_mac[5]);
+
+            if (!memcpy((unsigned char*) &desc->in.set_btm_request.peer_mac[0],
+                      (unsigned char*) sta_mac,
+                      sizeof(mac_address_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s peer_mac.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            if (!memcpy((unsigned char*) &desc->in.set_btm_request.request,
+                      (unsigned char*) arg3,
+                      sizeof(wifi_BTMRequest_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s wifi_BTMRequest_t.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_get_ssid_name:
+            if (!arg1) {
+                hal_wifi_print("%s:%d for RFC API function %s require 1 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_ssid_name.ap_index = *(INT*) arg1;
+            break;
+
+        case hal_ipc_desc_type_set_rm_beacon_request:
+            if (!arg1 || !arg2 || !arg3) {
+                hal_wifi_print("%s:%d for RFC API function %s require 3 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            desc->in.set_rm_beacon_request.ap_index = *(UINT*) arg1;
+
+            sscanf((char *)arg2, "%02x:%02x:%02x:%02x:%02x:%02x", &sta_mac[0], &sta_mac[1], &sta_mac[2],&sta_mac[3], &sta_mac[4], &sta_mac[5]);
+
+            if (!memcpy((unsigned char*) &desc->in.set_rm_beacon_request.peer_mac[0],
+                      (unsigned char*) sta_mac,
+                      sizeof(mac_address_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s peer_mac.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            if (!memcpy((unsigned char*) &desc->in.set_rm_beacon_request.in_request,
+                      (unsigned char*) arg3,
+                      sizeof(wifi_BeaconRequest_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s wifi_BeaconRequest_t.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_get_association_req_ies:
+            // Check BM config 
+            //
+            // CONFIG_RDK_HAS_ASSOC_REQ_IES !!!
+            //
+            if (!arg1 || !arg2 || !arg3) {
+                hal_wifi_print("%s:%d for RFC API function %s require 3 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            desc->in.get_association_req_ies.ap_index = *(UINT*) arg1;
+
+            if (!memcpy((unsigned char*) &desc->in.get_association_req_ies.client_mac_addr[0],
+                      (unsigned char*) arg2,
+                      sizeof(mac_address_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s client_mac_addr.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            desc->in.get_association_req_ies.req_ies_size = *(UINT*) arg3;
+            break;
+
+        case hal_ipc_desc_type_set_neighbor_reports:
+            if (!arg1 || !arg2 || !arg3) {
+                hal_wifi_print("%s:%d for RFC API function %s require 3 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            desc->in.set_neighbor_reports.ap_index = *(UINT*) arg1;
+
+            desc->in.set_neighbor_reports.num_neighbor_reports = *(UINT*) arg2;
+
+            if (desc->in.set_neighbor_reports.num_neighbor_reports > HAL_IPC_MAX_NEIGHBOR_AP_COUNT) {
+                hal_wifi_print("%s:%d truncate %s neighbor reports number to %d.\n", __func__, __LINE__, desc->name, HAL_IPC_MAX_NEIGHBOR_AP_COUNT);
+                desc->in.set_neighbor_reports.num_neighbor_reports = HAL_IPC_MAX_NEIGHBOR_AP_COUNT;
+            }
+
+            desc->scratch_buf = (unsigned char*) malloc(desc->in.set_neighbor_reports.num_neighbor_reports * sizeof(wifi_NeighborReport_t));
+
+            if (!desc->scratch_buf) {
+                hal_wifi_print("%s:%d FAIL to allocate memory for %d wifi_NeighborReport_t \n", __func__, __LINE__, desc->in.set_neighbor_reports.num_neighbor_reports); 
+                return -1;
+            }
+
+            desc->scratch_buf_size = desc->in.set_neighbor_reports.num_neighbor_reports * sizeof(wifi_NeighborReport_t);
+
+            if (!memcpy(desc->scratch_buf, (unsigned char*) arg3, desc->scratch_buf_size)) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s wifi_NeighborReport_t.\n", __func__, __LINE__, desc->name);
+                free(desc->scratch_buf);
+                return -1;
+            }
+
+            desc->len += desc->scratch_buf_size;
+            break;
+
+        case hal_ipc_desc_type_set_neighbor_report_activation:
+            if (!arg1 || !arg2) {
+                hal_wifi_print("%s:%d for RFC API function %s require 2 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.set_neighbor_report_activation.ap_index = *(UINT*) arg1;
+            desc->in.set_neighbor_report_activation.activate = *(BOOL*) arg2;
+            break;
+
+        case hal_ipc_desc_type_get_radio_if_name:
+            //get_radio_if_name
+            if (!arg1) {
+                hal_wifi_print("%s:%d for RFC API function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_radio_if_name.radio_index = *(INT*) arg1;
+            break;
+
+        case hal_ipc_desc_type_get_ap_num_assoc_devs:
+            if (!arg1) {
+                hal_wifi_print("%s:%d for RFC API function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            desc->in.get_ap_num_assoc_devs.ap_index = *(INT*) arg1;
+            break;
+
+        default:
+            break;
+    }
+    return 0;
+}
+
+//--------------------------------------------------------------------------------------------------
+int ipc_output_client(struct hal_ipc_processor_desc *desc,
+                      void *arg1,
+                      void *arg2,
+                      void *arg3,
+                      void *arg4,
+                      void *arg5)
+{
+    hal_wifi_print("%s:%d Enter: handled client output parameters for API %s\n", __func__, __LINE__, desc->name);
+
+    (void) arg4;
+    (void) arg5;
+
+    switch (desc->type) {
+        case hal_ipc_desc_type_set_radio_stats_enable:
+            // do nothing, just check for rfc return value
+            if (desc->ret) {
+                hal_wifi_print("%s:%d RFC API %s returned code %d \n", __func__, __LINE__, desc->name, desc->ret);
+                return desc->ret;
+            }
+            break;
+
+        case hal_ipc_desc_type_get_ssid_num_of_entries:
+            if (!arg1) {
+                hal_wifi_print("%s:%d for API %s function require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            *(ULONG*) arg1 = desc->out.get_ssid_num_entries.numEntries;
+            break;
+
+        case hal_ipc_desc_type_get_ap_assoc_dev_stats:
+            if (!arg1 || !arg2) {
+                hal_wifi_print("%s:%d function %s require 2 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            if (!memcpy((unsigned char*) arg1,
+                      (unsigned char*) &desc->out.get_ap_assoc_dev_stats.associated_dev_stats,
+                      sizeof(wifi_associated_dev_stats_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for associated_dev_stats.\n", __func__, __LINE__);
+                return -1;
+            }
+            *(ULLONG*) arg2 = desc->out.get_ap_assoc_dev_stats.handle;
+            break;
+
+        case hal_ipc_desc_type_get_radio_chan_stats:
+            if (!arg1) {
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            int stats_num = desc->in.get_radio_channel_stats.array_size;
+
+            if (desc->scratch_buf_size != stats_num*sizeof(wifi_channelStats_t)) {
+                hal_wifi_print("%s:%d FAIL incorrect data size.\n", __func__, __LINE__);
+                free(desc->scratch_buf);
+                return -1;
+            }
+
+            if (!memcpy((unsigned char*) arg1, (unsigned char*) desc->scratch_buf, desc->scratch_buf_size)) {
+                hal_wifi_print("%s:%d FAIL memcpy for %d input_output_channelStats_array.\n", __func__, __LINE__, stats_num);
+                free(desc->scratch_buf);
+                return -1;
+            }
+
+            free(desc->scratch_buf);
+            break;
+
+        case hal_ipc_desc_type_start_neighbor_scan:
+            if (!arg1) {
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            if (desc->in.start_neighbor_scan.scan_mode == WIFI_RADIO_SCAN_MODE_OFFCHAN) {
+                *(UINT*) arg1 = desc->out.start_neighbor_scan.chan_list;
+            }
+            break;
+
+        case hal_ipc_desc_type_get_neighbor_wifi_status:
+            if (!arg1 || !arg2) {
+                hal_wifi_print("%s:%d function %s require 2 arguments.\n", __func__, __LINE__, desc->name);
+                free(desc->scratch_buf);
+                return -1;
+            }
+
+            if (desc->out.get_neighbor_wifi_status.output_array_size > HAL_IPC_MAX_NEIGHBOR_AP_COUNT) {
+                hal_wifi_print("%s:%d function %s returned too big array size. Truncate to %d items.\n", __func__, __LINE__, desc->name, HAL_IPC_MAX_NEIGHBOR_AP_COUNT);
+                desc->out.get_neighbor_wifi_status.output_array_size = HAL_IPC_MAX_NEIGHBOR_AP_COUNT;
+            }
+
+            *(UINT*) arg2 = desc->out.get_neighbor_wifi_status.output_array_size;
+
+            if (desc->scratch_buf_size != desc->out.get_neighbor_wifi_status.output_array_size * sizeof(wifi_neighbor_ap2_t)) {
+                hal_wifi_print("%s:%d FAIL received incorrect data size.\n", __func__, __LINE__);
+                free(desc->scratch_buf);
+                return -1;
+            }
+
+            if (!memcpy((unsigned char*) arg1, desc->scratch_buf, desc->scratch_buf_size)) {
+                hal_wifi_print("%s:%d FAIL memcpy for %d neighbor_ap_array.\n", __func__, __LINE__, desc->out.get_neighbor_wifi_status.output_array_size);
+                free(desc->scratch_buf);
+                return -1;
+            }
+
+            free(desc->scratch_buf);
+            break;
+
+        case hal_ipc_desc_type_get_ssid_traffic_stats2:
+            if (!arg1) {
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            if (!memcpy((unsigned char*) arg1,
+                      (unsigned char*) &desc->out.get_ssid_traffic_stats2.output_struct,
+                      sizeof(wifi_ssidTrafficStats2_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s output_struct.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_get_ap_assoc_dev_rx_stats_result:
+            if (!arg1 || !arg2 || !arg3) {
+                hal_wifi_print("%s:%d function %s require 3 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            if (desc->out.get_ap_assoc_dev_rx_stats_result.output_array_size > HAL_IPC_MAX_STATS_ARRAY_NUM) {
+                hal_wifi_print("%s:%d function %s returned too big array size. Truncate to %d items.\n", __func__, __LINE__, desc->name, HAL_IPC_MAX_STATS_ARRAY_NUM);
+                desc->out.get_ap_assoc_dev_rx_stats_result.output_array_size = HAL_IPC_MAX_STATS_ARRAY_NUM;
+                desc->scratch_buf_size = HAL_IPC_MAX_STATS_ARRAY_NUM * sizeof(wifi_associated_dev_rate_info_rx_stats_t);
+            }
+
+            *(UINT*) arg2 = desc->out.get_ap_assoc_dev_rx_stats_result.output_array_size;
+
+            if (desc->scratch_buf_size != desc->out.get_ap_assoc_dev_rx_stats_result.output_array_size * sizeof(wifi_associated_dev_rate_info_rx_stats_t)) {
+                hal_wifi_print("%s:%d FAIL received incorrect data size.\n", __func__, __LINE__);
+                free(desc->scratch_buf);
+                return -1;
+            }
+
+            if (!memcpy((unsigned char*) arg1,
+                        desc->scratch_buf,
+                        desc->out.get_ap_assoc_dev_rx_stats_result.output_array_size*sizeof(wifi_associated_dev_rate_info_rx_stats_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s stats_array.\n", __func__, __LINE__, desc->name);
+                free(desc->scratch_buf);
+                return -1;
+            }
+
+            *(ULLONG*) arg3 = desc->out.get_ap_assoc_dev_rx_stats_result.handle;
+
+            free(desc->scratch_buf);
+            break;
+
+        case hal_ipc_desc_type_get_ssid_enable:
+            if (!arg1) {
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            *(BOOL*) arg1 = desc->out.get_ssid_enable.output_bool;
+            break;
+
+        case hal_ipc_desc_type_get_ssid_radio_index:
+            if (!arg1) {
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            *(INT*) arg1 = desc->out.get_ssid_radio_index.radio_index;
+            break;
+
+        case hal_ipc_desc_type_get_ssid_name_status:
+            if (!arg1) {
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            INT ssid_status_str_len = strlen(desc->out.get_ssid_name_status.output_string);
+            if (!ssid_status_str_len) {
+                hal_wifi_print("%s:%d RFC API %s returned empty SSID status string for AP index %d.\n", __func__, __LINE__, desc->name, desc->in.get_ssid_name_status.ap_index);
+                return -1;
+            }
+
+            if (!memcpy((unsigned char*) arg1,
+                      (unsigned char*) &desc->out.get_ssid_name_status.output_string[0],
+                      ssid_status_str_len + 1)) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s output_string.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_get_ap_name:
+            if (!arg1) {
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            INT ap_name_str_len = strlen(desc->out.get_ap_name.output_string);
+            if (!ap_name_str_len) {
+                hal_wifi_print("%s:%d RFC API %s returned empty SSID status string for AP index %d.\n", __func__, __LINE__, desc->name, desc->in.get_ssid_name_status.ap_index);
+                return -1;
+            }
+
+            if (!memcpy((unsigned char*) arg1, 
+                      (unsigned char*) &desc->out.get_ap_name.output_string[0],
+                      ap_name_str_len)) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s output_string.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_get_neighbor_report_activation:
+            if (!arg1) {
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            *(BOOL*) arg1 = desc->out.get_neighbor_report_activation.activate;
+            break;
+
+        case hal_ipc_desc_type_get_bss_transition_activation:
+            if (!arg1) {
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            *(BOOL*) arg1 = desc->out.get_bss_transition_activation.activate;
+            break;
+
+        case hal_ipc_desc_type_get_ap_assoc_dev_diag_result3:
+            if (!arg1 || !arg2) {
+                hal_wifi_print("%s:%d function %s require 2 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            if (!desc->out.get_ap_assoc_dev_diag_result3.num) {
+                hal_wifi_print("%s:%d: function %s returned no data.\n", __func__, __LINE__, desc->name);
+                *(unsigned int*) arg2 = 0;
+                return 0;
+            }
+
+            if (desc->out.get_ap_assoc_dev_diag_result3.num > HAL_IPC_MAX_STA_SUPPORT_NUM) {
+                hal_wifi_print("%s:%d function %s returned too big array size. Truncate to %d items.\n", __func__, __LINE__, desc->name, HAL_IPC_MAX_STA_SUPPORT_NUM);
+                desc->out.get_ap_assoc_dev_diag_result3.num = HAL_IPC_MAX_STA_SUPPORT_NUM; 
+                desc->scratch_buf_size = HAL_IPC_MAX_STA_SUPPORT_NUM*sizeof(wifi_associated_dev3_t);
+            }
+            *(unsigned int*) arg2 = desc->out.get_ap_assoc_dev_diag_result3.num;
+
+            if (desc->scratch_buf_size != desc->out.get_ap_assoc_dev_diag_result3.num*sizeof(wifi_associated_dev3_t)) {
+                hal_wifi_print("%s:%d %s data size incorrect. Desc buf size: %d, expected: %d\n", __func__, __LINE__, desc->name,
+                        desc->scratch_buf_size, desc->out.get_ap_assoc_dev_diag_result3.num*sizeof(wifi_associated_dev3_t));
+                free(desc->scratch_buf);
+                return -1;
+            }
+
+            hal_wifi_print("%s:%d %s copy %d diag result3 structs.\n", __func__, __LINE__, desc->name, desc->out.get_ap_assoc_dev_diag_result3.num);
+            
+            if (!memcpy((unsigned char*) arg1,
+                       (unsigned char*) desc->scratch_buf,
+                       desc->out.get_ap_assoc_dev_diag_result3.num*sizeof(wifi_associated_dev3_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for %d wifi_associated_dev3_t array.\n", __func__, __LINE__, desc->out.get_ap_assoc_dev_diag_result3.num);
+                free(desc->scratch_buf);
+                return -1;
+            }
+
+            free(desc->scratch_buf);
+            break;
+
+        case hal_ipc_desc_type_get_ap_assoc_client_diag_result:
+            if (!arg1) {
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            if (!memcpy((unsigned char*) arg1,
+                       (unsigned char*) &desc->out.get_ap_assoc_client_diag_result.dev_conn,
+                       sizeof(wifi_associated_dev3_t))) {
+                hal_wifi_print("%s:%d FAIL memcpy for wifi_associated_dev3_t struct.\n", __func__, __LINE__);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_get_radio_operating_freq_band:
+            if (!arg1) {
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            int radio_oper_freq_band_str_len = strlen(desc->out.get_radio_operating_freq_band.output_string);
+            if (!radio_oper_freq_band_str_len) {
+                hal_wifi_print("%s:%d RFC API %s returned empty string of radio operating frequency band for radio index %d.\n", __func__, __LINE__, desc->name, desc->in.get_radio_operating_freq_band.radio_index);
+                return -1;
+            }
+            if (!memcpy((unsigned char*) arg1,
+                       (unsigned char*) &desc->out.get_radio_operating_freq_band.output_string[0],
+                       radio_oper_freq_band_str_len + 1)) {
+                hal_wifi_print("%s:%d FAIL memcpy for %s output_string.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_get_radio_num_of_entries:
+            if (!arg1) {
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            *(unsigned long*) arg1 = desc->out.get_radio_number_of_entries.output;
+            break;
+
+        case hal_ipc_desc_type_get_ap_assoc_dev_tx_stats_result:
+            if (!arg1 || !arg2 || !arg3) {
+                hal_wifi_print("%s:%d function %s require 3 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            if (desc->out.get_ap_assoc_dev_tx_stats_result.output_array_size > HAL_IPC_MAX_STATS_ARRAY_NUM) {
+                hal_wifi_print("%s:%d function %s returned too big array size. Truncate to %d items.\n", __func__, __LINE__, desc->name, HAL_IPC_MAX_STATS_ARRAY_NUM);
+                desc->out.get_ap_assoc_dev_tx_stats_result.output_array_size = HAL_IPC_MAX_STATS_ARRAY_NUM;
+            }
+
+            *(UINT*) arg2 = desc->out.get_ap_assoc_dev_tx_stats_result.output_array_size;
+
+            if (desc->scratch_buf_size != desc->out.get_ap_assoc_dev_tx_stats_result.output_array_size * sizeof(wifi_associated_dev_rate_info_tx_stats_t)) {
+                hal_wifi_print("%s:%d FAIL received incorrect data size.\n", __func__, __LINE__, desc->name);
+                free(desc->scratch_buf);
+                return -1;
+            }
+
+            if(!memcpy((unsigned char*) arg1,
+                      desc->scratch_buf,
+                      desc->out.get_ap_assoc_dev_tx_stats_result.output_array_size*sizeof(wifi_associated_dev_rate_info_tx_stats_t)))
+            {
+                hal_wifi_print("%s:%d FAIL memcpy for %s stats_array.\n", __func__, __LINE__, desc->name); 
+                free(desc->scratch_buf);
+                return -1;
+            }
+
+            *(ULLONG*) arg3 = desc->out.get_ap_assoc_dev_tx_stats_result.handle;
+
+            free(desc->scratch_buf);
+            break;
+
+        case hal_ipc_desc_type_steering_set_group:
+            if(!arg1 || !arg2){
+                hal_wifi_print("%s:%d function %s require 2 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            if(!memcpy((unsigned char*) arg1,
+                        (unsigned char*) &desc->out.set_steering_group.cfg_2,
+                        sizeof(wifi_steering_apConfig_t)))
+            {
+                hal_wifi_print("%s:%d FAIL memcpy for %s wifi_steering_apConfig_t 2.4GHz.\n", __func__, __LINE__, desc->name); 
+                return -1;
+            }
+
+            if(!memcpy((unsigned char*) arg2,
+                        (unsigned char*) &desc->out.set_steering_group.cfg_5,
+                        sizeof(wifi_steering_apConfig_t)))
+            {
+                hal_wifi_print("%s:%d FAIL memcpy for %s wifi_steering_apConfig_t 5GHz.\n", __func__, __LINE__, desc->name); 
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_steering_client_set:
+            if(!arg1){
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            if(!memcpy((unsigned char*) arg1,
+                        (unsigned char*) &desc->out.set_steering_client.config,
+                        sizeof(wifi_steering_clientConfig_t)))
+            {
+                hal_wifi_print("%s:%d FAIL memcpy for %s wifi_steering_clientConfig_t.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            break;
+
+        case hal_ipc_desc_type_get_ssid_name:
+            if(!arg1){
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            int ssid_name_str_len = strlen(desc->out.get_ssid_name.output_string);
+            if(!ssid_name_str_len){
+                hal_wifi_print("%s:%d RFC API %s returned empty string AP index %d.\n", __func__, __LINE__, desc->name, desc->in.get_ssid_name.ap_index);
+                return -1; 
+            }
+            if(!memcpy((unsigned char*) arg1,
+                       (unsigned char*) &desc->out.get_ssid_name.output_string[0],
+                       ssid_name_str_len + 1))
+            {
+                hal_wifi_print("%s:%d FAIL memcpy for %s output_string.\n", __func__, __LINE__, desc->name); 
+                return -1; 
+            }
+            break;
+
+        case hal_ipc_desc_type_set_rm_beacon_request:
+            if(!arg1){
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            
+            *(UCHAR*) arg1 = desc->out.set_rm_beacon_request.dialog_token;
+            break;
+
+        case hal_ipc_desc_type_get_association_req_ies:
+            if(!arg1 || !arg2){
+                hal_wifi_print("%s:%d function %s require 2 arguments.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            if(!memcpy((unsigned char*) arg1,
+                       (unsigned char*) &desc->out.get_association_req_ies.req_ies[0],
+                       HAL_IPC_ASSOC_REQ_IES_BUF_SIZE))
+            {
+                hal_wifi_print("%s:%d FAIL memcpy for %s output_string.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+
+            break;
+
+        case hal_ipc_desc_type_set_neighbor_report_activation:
+            //set_neighbor_report_activation
+            break;
+
+        case hal_ipc_desc_type_get_radio_if_name:
+            if(!arg1){
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            int radio_if_name_str_len = strlen(desc->out.get_radio_if_name.output_string);
+            if(!radio_if_name_str_len){
+                hal_wifi_print("%s:%d RFC API %s returned empty string of interface name radio index %d.\n", __func__, __LINE__, desc->name, desc->in.get_radio_if_name.radio_index);
+                return -1;
+            }
+
+            if(!memcpy((unsigned char*) arg1,
+                       (unsigned char*) &desc->out.get_radio_if_name.output_string[0],
+                       radio_if_name_str_len))
+            {
+                hal_wifi_print("%s:%d FAIL memcpy for %s output_string.\n", __func__, __LINE__, desc->name); 
+                return -1; 
+            }
+
+            hal_wifi_print("%s:%d %s returned radio interface name %s for radio index %d.\n", __func__, __LINE__, desc->name, (unsigned char*) arg1, desc->in.get_radio_if_name.radio_index);
+            break;
+
+        case hal_ipc_desc_type_get_ap_num_assoc_devs:
+            //get_ap_num_assoc_devs
+            if(!arg1){
+                hal_wifi_print("%s:%d function %s require 1 argument.\n", __func__, __LINE__, desc->name);
+                return -1;
+            }
+            *(ULONG*) arg1 = desc->out.get_ap_num_assoc_devs.output;
+            break;
+
+        default:
+            hal_wifi_print("%s:%d RFC API %s reached default.\n", __func__, __LINE__, desc->name);
+            break;
+    }
+	return 0;
+}
+
+
+//--------------------------------------------------------------------------------------------------
+int server_ipc_notification_output(struct hal_ipc_processor_desc *desc,
+                                   void *arg1,
+                                   void *arg2,
+                                   void *arg3,
+                                   void *arg4,
+                                   void *arg5)
+{
+    (void) arg1;
+    (void) arg2;
+    (void) arg3;
+    (void) arg4;
+    (void) arg5;
+
+    hal_wifi_print("%s:%d Enter: notification server. API %s\n", __func__, __LINE__, desc->name);
+    switch(desc->type){
+        case hal_ipc_desc_type_steering_event:;
+            wifi_steering_eventCB_t client_steering_event_callback = NULL;
+            client_steering_event_callback = hal_ipc_get_client_steering_callback();
+            if(!client_steering_event_callback){
+                hal_wifi_print("%s:%d: FAIL client's steering event callback is NULL pointer.\n", __func__, __LINE__);
+                return -1;
+            }
+            unsigned int steering_group_index = desc->in.steering_event_data.steering_group_index;
+            wifi_steering_event_t evt;
+            if(!memcpy((unsigned char*) &evt,
+                       (unsigned char*) &desc->in.steering_event_data.evt,
+                       sizeof(wifi_steering_event_t)))
+            {
+                hal_wifi_print("%s:%d FAIL memcpy %s wifi_steering_event_t\n", __func__, __LINE__, desc->name);
+                return -1; 
+            }
+            client_steering_event_callback(steering_group_index, &evt);
+            hal_wifi_print("%s:%d steering event processing finished.\n", __func__, __LINE__);
+            break;
+
+        case hal_ipc_desc_type_mgmt_frame_event:
+
+            break;
+
+        case hal_ipc_rm_beacon_report_event:
+            {
+                wifi_RMBeaconReport_callback client_rm_beacon_report_cb = NULL;
+
+                UINT apIndex = desc->in.rm_beacon_report_event_data.apIndex;
+                wifi_BeaconReport_t sta_beacon_report;
+                UINT out_arr_size = desc->in.rm_beacon_report_event_data.out_array_size;
+                UCHAR out_dialog_token = desc->in.rm_beacon_report_event_data.out_DialogToken;
+                int ret = 0;
+
+                client_rm_beacon_report_cb = hal_ipc_get_client_rm_beacon_report_callback(apIndex);
+                if(!client_rm_beacon_report_cb){
+                    hal_wifi_print("%s:%d: FAIL AP index %d client's RM beacon report event callback is NULL pointer.\n", __func__, __LINE__, desc->in.rm_beacon_report_event_data.apIndex);
+                    return -1;
+                }
+
+                if (desc->scratch_buf_size != sizeof(wifi_BeaconReport_t)) {
+                    hal_wifi_print("%s:%d FAIL %s: incorrect desc buf data size - recvd: %d, expected - %d\n", __func__, __LINE__, desc->name, desc->scratch_buf_size, sizeof(wifi_BeaconReport_t));
+                    return -1;
+                }
+                
+                if(!memcpy((unsigned char*) &sta_beacon_report,
+                       (unsigned char*) desc->scratch_buf,
+                       sizeof(wifi_BeaconReport_t))) {
+                    hal_wifi_print("%s:%d FAIL memcpy %s wifi_BeaconReport_t\n", __func__, __LINE__, desc->name);
+                    return -1;
+                }
+                
+                if ((ret = client_rm_beacon_report_cb(apIndex, &sta_beacon_report, &out_arr_size, &out_dialog_token))) {
+                    hal_wifi_print("%s:%d FAIL AP index %d RM Beacon Report callback returned %d\n", __func__, __LINE__, apIndex, ret);
+                    return -1;
+                }
+            }
+            break;
+
+        case hal_ipc_btm_query_request_event:
+            {
+                int ret = 0;
+                wifi_BTMQueryRequest_callback client_btm_query_request_cb = NULL;
+                UINT apIndex = desc->in.btm_query_request_event_data.apIndex;
+                UINT inMemSize = desc->in.btm_query_request_event_data.inMemSize;
+
+                wifi_BTMQuery_t     client_query;
+                wifi_BTMRequest_t   request;
+
+                if (!memcpy((unsigned char*) &client_query,
+                       (unsigned char*) &desc->in.btm_query_request_event_data.query,
+                       sizeof(wifi_BTMQuery_t))) {
+                    hal_wifi_print("%s:%d FAIL memcpy %s wifi_BeaconReport_t\n", __func__, __LINE__, desc->name);
+                    return -1;
+                }
+                
+                client_btm_query_request_cb = hal_ipc_get_btm_query_request_callback(apIndex);
+                if (!client_btm_query_request_cb) {
+                    hal_wifi_print("%s:%d: FAIL AP index %d client's BTM query/request event callback is NULL pointer.\n", __func__, __LINE__, desc->in.rm_beacon_report_event_data.apIndex);
+                    return -1;
+                }
+                
+                if ((ret = client_btm_query_request_cb(apIndex, 
+                                desc->in.btm_query_request_event_data.peerMac,
+                                &client_query,
+                                inMemSize,
+                                &request))) {
+                    hal_wifi_print("%s:%d FAIL AP index %d BTM query/request callback returned %d\n", __func__, __LINE__, apIndex, ret);
+                    return -1;
+                }
+
+                // copy request frame to current descriptor to send back to BTM query/request event initiator (STA)
+                if (!memcpy((unsigned char*) &desc->in.btm_query_request_event_data.request,
+                       (unsigned char*) &request,
+                       sizeof(wifi_BTMRequest_t))) {
+                    hal_wifi_print("%s:%d FAIL memcpy %s wifi_BTMRequest_t\n", __func__, __LINE__, desc->name);
+                    return -1;
+                }
+            }
+            break;
+
+        case hal_ipc_btm_response_event:
+            {
+                int ret = 0;
+                wifi_BTMResponse_callback client_btm_response_cb = NULL;
+                UINT apIndex = desc->in.btm_response_event_data.apIndex;
+                wifi_BTMResponse_t client_response;
+
+                if(!memcpy((unsigned char*) &client_response,
+                       (unsigned char*) &desc->in.btm_response_event_data.response,
+                       sizeof(wifi_BTMResponse_t))) {
+                    hal_wifi_print("%s:%d FAIL memcpy %s wifi_BTMResponse_t\n", __func__, __LINE__, desc->name);
+                    return -1;
+                }
+
+                client_btm_response_cb = hal_ipc_get_btm_response_callback(apIndex);
+                if(!client_btm_response_cb) {
+                    hal_wifi_print("%s:%d: FAIL AP index %d client's BTM response event callback is NULL pointer.\n", __func__, __LINE__, desc->in.rm_beacon_report_event_data.apIndex);
+                    return -1;
+                }
+                if ((ret = client_btm_response_cb(apIndex, desc->in.btm_response_event_data.peerMac, &client_response))) {
+                    hal_wifi_print("%s:%d FAIL AP index %d BTM response callback returned %d\n", __func__, __LINE__, apIndex, ret);
+                    return -1;
+                }
+            }
+
+            break;
+
+        default:
+            hal_wifi_print("%s:%d RFC API %s reached default.\n", __func__, __LINE__, desc->name);
+            return -1;
+            break;
+    }
+    return 0;
+}
+
diff --git wifi/wifi_hal.c wifi/wifi_hal.c
index 4653a7c..4472c5a 100644
--- wifi/wifi_hal.c
+++ wifi/wifi_hal.c
@@ -61,9 +61,12 @@
 #define RADIO_PREFIX	"wifi"
 #endif
 
+#include "client_hal_ipc_api.h"
+
+
 INT wifi_setRadioStatsEnable(INT radioIndex, BOOL enable)
 {
-    return RETURN_OK;
+    return ipc_wifi_setRadioStatsEnable(radioIndex, enable);
 }
 
 INT wifi_getApSecurityMFPConfig(INT apIndex, CHAR *output_string)
@@ -118,7 +121,7 @@
 
 INT wifi_getApAssociatedClientDiagnosticResult(INT apIndex, char *mac_addr, wifi_associated_dev3_t *dev_conn)
 {
-    return RETURN_ERR;
+    return ipc_wifi_getApAssociatedClientDiagnosticResult(apIndex, mac_addr, dev_conn);
 }
 
 INT wifi_getApWpaEncryptionMode(INT apIndex, CHAR *output_string)
@@ -137,6 +140,7 @@
 
 void wifi_newApAssociatedDevice_callback_register(wifi_newApAssociatedDevice_callback callback_proc)
 {
+    return;
 }
 
 INT wifi_getApBasicAuthenticationMode(INT apIndex, CHAR *authMode)
@@ -171,7 +175,7 @@
 
 INT wifi_getApAssociatedDeviceDiagnosticResult3(INT apIndex, wifi_associated_dev3_t **associated_dev_array, UINT *output_array_size)
 {
-    return RETURN_ERR;
+    return ipc_wifi_getApAssociatedDeviceDiagnosticResult3(apIndex, associated_dev_array, output_array_size);
 }
 
 INT wifi_switchBand(char *interface_name, INT radioIndex, char *freqBand)
@@ -436,6 +440,18 @@
 	return RETURN_OK;
 }
 
+//--------------------------------------------------------------------------------------------------
+INT wifi_setZeroDFSState(UINT radioIndex, BOOL enable, BOOL precac)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_getZeroDFSState(UINT radioIndex, BOOL *enable, BOOL *precac)
+{
+    return RETURN_ERR;
+}
+
 INT wifi_setRadioCountryCode(INT radioIndex, CHAR *CountryCode)
 {
 	//Set wifi config. Wait for wifi reset to apply
@@ -451,15 +467,13 @@
 //Get the total number of radios in this wifi subsystem
 INT wifi_getRadioNumberOfEntries(ULONG *output) //Tr181
 {
-	*output=2;
-	return RETURN_OK;
+    return ipc_wifi_getRadioNumberOfEntries(output);
 }
 
 //Get the total number of SSID entries in this wifi subsystem 
 INT wifi_getSSIDNumberOfEntries(ULONG *output) //Tr181
 {
-	*output=16;
-	return RETURN_OK;
+    return ipc_wifi_getSSIDNumberOfEntries(output);
 }
 
 //Get the Radio enable config parameter
@@ -494,17 +508,7 @@
 //Get the Radio Interface name from platform, eg "wifi0"
 INT wifi_getRadioIfName(INT radioIndex, CHAR *output_string) //Tr181
 {
-	errno_t rc = -1;
-	if(radioIndex < 0 || radioIndex > 1)
-		return RETURN_ERR;
-	if (NULL == output_string) 
-		return RETURN_ERR;
-	rc = sprintf_s(output_string, 64, "%s%d", RADIO_PREFIX, radioIndex);
-	if(rc < EOK)
-	{
-		ERR_CHK(rc);
-	}
-	return RETURN_OK;
+    return ipc_wifi_getRadioIfName(radioIndex, output_string);
 }
 
 //Get the maximum PHY bit rate supported by this interface. eg: "216.7 Mb/s", "1.3 Gb/s"
@@ -551,12 +555,7 @@
 //The output_string is a max length 64 octet string that is allocated by the RDKB code.  Implementations must ensure that strings are not longer than this.
 INT wifi_getRadioOperatingFrequencyBand(INT radioIndex, CHAR *output_string) //Tr181
 {
-	errno_t rc = -1;
-	if (NULL == output_string) 
-		return RETURN_ERR;
-	rc = strcpy_s(output_string, 64, (radioIndex==0)?"2.4GHz":"5GHz");
-	ERR_CHK(rc);
-	return RETURN_OK;
+    return ipc_wifi_getRadioOperatingFrequencyBand(radioIndex, output_string);
 }
 
 //Get the Supported Radio Mode. eg: "b,g,n"; "n,ac"
@@ -592,7 +591,6 @@
 		*acOnly=FALSE;	
 	}
 	return RETURN_OK;
-
 }
 
 //Set the radio operating mode, and pure mode flag. 
@@ -657,11 +655,11 @@
 		//result = 0;		
 	}	
 
-	/*
-	   struct _COSA_DML_WIFI_RADIO_CFG is packed, so we can't rely on the elements
-	   within it being correctly aligned. Therefore memcpy into output_ulong,
-	   which is always safe to do.
-	*/
+	
+	//   struct _COSA_DML_WIFI_RADIO_CFG is packed, so we can't rely on the elements
+	//   within it being correctly aligned. Therefore memcpy into output_ulong,
+	//   which is always safe to do.
+	
 	memcpy (output_ulong, &result, sizeof(*output_ulong));
 
 	return RETURN_OK;
@@ -711,6 +709,12 @@
 		return RETURN_ERR;
 	*output_bool=FALSE;	
 	return RETURN_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_isZeroDFSSupported(UINT radioIndex, BOOL *supported)
+{
+    return RETURN_OK;
 }
 
 //The output_string is a max length 256 octet string that is allocated by the RDKB code.  Implementations must ensure that strings are not longer than this.
@@ -1129,43 +1133,9 @@
 // Outputs a 32 byte or less string indicating the SSID name.  Sring buffer must be preallocated by the caller.
 INT wifi_getSSIDName(INT apIndex, CHAR *output)
 {
-	errno_t rc = -1;
-	if (NULL == output) 
-		return RETURN_ERR;
-	if(apIndex==0)
-	{
-		rc = strcpy_s(output, 64, "HOME-XXXX-2.4");
-		ERR_CHK(rc);
-	}
-	else if(apIndex==1)
-	{
-		rc = strcpy_s(output, 64, "HOME-XXXX-5");
-		ERR_CHK(rc);
-	}
-	else if(apIndex==2)
-	{
-		rc = strcpy_s(output, 64, "XHS-XXXXXX");
-		ERR_CHK(rc);
-	}
-	else if(apIndex==4)
-	{
-		rc = strcpy_s(output, 64, "Xfinitywifi-2.4");
-		ERR_CHK(rc);
-	}
-	else if(apIndex==5)
-	{
-		rc = strcpy_s(output, 64, "Xfinitywifi-5");
-		ERR_CHK(rc);
-	}
-	else
-	{
-		rc = strcpy_s(output, 64, "OOS");
-		ERR_CHK(rc);
-	}
-	return RETURN_OK;
-
+    return ipc_wifi_getSSIDName(apIndex, output);
 }
-        
+
 // Set a max 32 byte string and sets an internal variable to the SSID name          
 INT wifi_setSSIDName(INT apIndex, CHAR *ssid_string)
 {
@@ -1215,48 +1185,14 @@
 //Get the basic SSID traffic static info
 INT wifi_getSSIDTrafficStats2(INT ssidIndex, wifi_ssidTrafficStats2_t *output_struct) //Tr181
 {
-	char cmd[128]={0};
-	char buf[1024]={0};
-	errno_t rc = -1;
-	
-	rc = sprintf_s(cmd, sizeof(cmd), "ifconfig %s%d ", AP_PREFIX, ssidIndex);
-	if(rc < EOK)
-    {
-        ERR_CHK(rc);
-    }
-    _syscmd(cmd, buf, sizeof(buf));
-	
-	output_struct->ssid_BytesSent		=2048;	//The total number of bytes transmitted out of the interface, including framing characters.
-	output_struct->ssid_BytesReceived	=4096;	//The total number of bytes received on the interface, including framing characters.
-	output_struct->ssid_PacketsSent		=128;	//The total number of packets transmitted out of the interface.
-	output_struct->ssid_PacketsReceived	=128; //The total number of packets received on the interface.
-
-	output_struct->ssid_RetransCount	=0;	//The total number of transmitted packets which were retransmissions. Two retransmissions of the same packet results in this counter incrementing by two.
-	output_struct->ssid_FailedRetransCount=0; //The number of packets that were not transmitted successfully due to the number of retransmission attempts exceeding an 802.11 retry limit. This parameter is based on dot11FailedCount from [802.11-2012].	
-	output_struct->ssid_RetryCount		=0;  //The number of packets that were successfully transmitted after one or more retransmissions. This parameter is based on dot11RetryCount from [802.11-2012].	
-	output_struct->ssid_MultipleRetryCount=0; //The number of packets that were successfully transmitted after more than one retransmission. This parameter is based on dot11MultipleRetryCount from [802.11-2012].	
-	output_struct->ssid_ACKFailureCount	=0;  //The number of expected ACKs that were never received. This parameter is based on dot11ACKFailureCount from [802.11-2012].	
-	output_struct->ssid_AggregatedPacketCount=0; //The number of aggregated packets that were transmitted. This applies only to 802.11n and 802.11ac.	
-
-	output_struct->ssid_ErrorsSent		=0;	//The total number of outbound packets that could not be transmitted because of errors.
-	output_struct->ssid_ErrorsReceived	=0;    //The total number of inbound packets that contained errors preventing them from being delivered to a higher-layer protocol.
-	output_struct->ssid_UnicastPacketsSent=2;	//The total number of inbound packets that contained errors preventing them from being delivered to a higher-layer protocol.
-	output_struct->ssid_UnicastPacketsReceived=2;  //The total number of received packets, delivered by this layer to a higher layer, which were not addressed to a multicast or broadcast address at this layer.
-	output_struct->ssid_DiscardedPacketsSent=1; //The total number of outbound packets which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space.
-	output_struct->ssid_DiscardedPacketsReceived=1; //The total number of inbound packets which were chosen to be discarded even though no errors had been detected to prevent their being delivered. One possible reason for discarding such a packet could be to free up buffer space.
-	output_struct->ssid_MulticastPacketsSent=10; //The total number of packets that higher-level protocols requested for transmission and which were addressed to a multicast address at this layer, including those that were discarded or not sent.
-	output_struct->ssid_MulticastPacketsReceived=0; //The total number of received packets, delivered by this layer to a higher layer, which were addressed to a multicast address at this layer.  
-	output_struct->ssid_BroadcastPacketsSent=0;  //The total number of packets that higher-level protocols requested for transmission and which were addressed to a broadcast address at this layer, including those that were discarded or not sent.
-	output_struct->ssid_BroadcastPacketsRecevied=1; //The total number of packets that higher-level protocols requested for transmission and which were addressed to a broadcast address at this layer, including those that were discarded or not sent.
-	output_struct->ssid_UnknownPacketsReceived=0;  //The total number of packets received via the interface which were discarded because of an unknown or unsupported protocol.
-	return RETURN_OK;
+    return ipc_wifi_getSSIDTrafficStats2(ssidIndex, output_struct);
 }
 
 //Apply SSID and AP (in the case of Acess Point devices) to the hardware
 //Not all implementations may need this function.  If not needed for a particular implementation simply return no-error (0)
 INT wifi_applySSIDSettings(INT ssidIndex)
 {
-	return RETURN_OK;
+	return RETURN_ERR;
 }
 
 
@@ -1731,15 +1667,7 @@
 // Outputs a 16 byte or less name assocated with the AP.  String buffer must be pre-allocated by the caller
 INT wifi_getApName(INT apIndex, CHAR *output_string)
 {
-	errno_t rc = -1;
-	if (NULL == output_string) 
-		return RETURN_ERR;
-	rc = sprintf_s(output_string, 16, "%s%d", AP_PREFIX, apIndex);
-	if(rc < EOK)
-    {
-        ERR_CHK(rc);
-    }
-	return RETURN_OK;
+    return ipc_wifi_getApName(apIndex, output_string);
 }     
        
 // Outputs the index number in that corresponds to the SSID string
@@ -1879,18 +1807,7 @@
 // Outputs the number of stations associated per AP
 INT wifi_getApNumDevicesAssociated(INT apIndex, ULONG *output_ulong)
 {
-	char cmd[128]={0};
-	char buf[128]={0};
-	errno_t rc = -1;
-		
-	rc = sprintf_s(cmd, sizeof(cmd), "wlanconfig %s%d list sta | grep -v HTCAP | wc -l", AP_PREFIX, apIndex);
-	if(rc < EOK)
-    {
-        ERR_CHK(rc);
-    }
-	_syscmd(cmd, buf, sizeof(buf));
-	sscanf(buf,"%lu", output_ulong);
-	return RETURN_OK;
+    return ipc_wifi_getApNumDevicesAssociated(apIndex, output_ulong);
 }
 
 // manually removes any active wi-fi association with the device specified on this ap
@@ -1915,7 +1832,7 @@
 
 // Get the ACL MAC list per AP
 INT wifi_getApAclDevices(INT apIndex, CHAR *macArray, UINT buf_size) 
-{		
+{	    
 	errno_t rc = -1;
 	rc = strcpy_s(macArray, buf_size, "11:22:33:44:55:66\n11:22:33:44:55:67\n");
 	ERR_CHK(rc);
@@ -2146,7 +2063,7 @@
 	if(!output_bool)
 		return RETURN_ERR;
 	*output_bool=TRUE;	
-	return RETURN_OK;	
+	return RETURN_OK;  
 }
 
 // sets an internal variable for ssid advertisement.  Set to 1 to enable, set to 0 to disable
@@ -2240,6 +2157,7 @@
 		return RETURN_ERR;
 	*output=TRUE;	
 	return RETURN_OK;
+
 }
 	
 INT wifi_setApIsolationEnable(INT apIndex, BOOL enable)
@@ -2386,6 +2304,8 @@
 //The IP Address and port number of the RADIUS server used for WLAN security. RadiusServerIPAddr is only applicable when ModeEnabled is an Enterprise type (i.e. WPA-Enterprise, WPA2-Enterprise or WPA-WPA2-Enterprise).
 INT wifi_getApSecurityRadiusServer(INT apIndex, CHAR *IP_output, UINT *Port_output, CHAR *RadiusSecret_output)
 {
+    return wifi_getApSecurityRadiusServer(apIndex, IP_output, Port_output, RadiusSecret_output);
+    /*
 	errno_t rc = -1;
 
 	if(!IP_output || !Port_output || !RadiusSecret_output)
@@ -2396,6 +2316,7 @@
 	rc = strcpy_s(RadiusSecret_output, 64, "12345678");
 	ERR_CHK(rc);
 	return RETURN_OK;
+    */
 }
 
 INT wifi_setApSecurityRadiusServer(INT apIndex, CHAR *IPAddress, UINT port, CHAR *RadiusSecret)
@@ -3182,75 +3103,171 @@
 
 INT wifi_chan_eventRegister(wifi_chan_eventCB_t eventCb)
 {
-    return RETURN_ERR;
+	return RETURN_ERR;
 }
 
 INT wifi_setNeighborReportActivation(UINT apIndex, BOOL activate)
 {
-    return RETURN_ERR;
+    return ipc_wifi_setNeighborReportActivation(apIndex, activate);
 }
 
 INT wifi_getNeighborReportActivation(UINT apIndex, BOOL *activate)
 {
-    return RETURN_ERR;
+    return ipc_wifi_getNeighborReportActivation(apIndex, activate);
 }
 
 INT wifi_setBTMRequest(UINT apIndex, CHAR *peerMac, wifi_BTMRequest_t *request)
 {
-    return RETURN_ERR;
+    return ipc_wifi_setBTMRequest(apIndex, peerMac, request);
 }
 
 INT wifi_setRMBeaconRequest(UINT apIndex, CHAR *peer, wifi_BeaconRequest_t *in_request, UCHAR *out_DialogToken)
 {
-    return RETURN_ERR;
+    return ipc_wifi_setRMBeaconRequest(apIndex, peer, in_request, out_DialogToken);
 }
 
 INT wifi_startNeighborScan(INT apIndex, wifi_neighborScanMode_t scan_mode, INT dwell_time, UINT chan_num, UINT *chan_list)
 {
-    return RETURN_OK;
+    return ipc_wifi_startNeighborScan(apIndex, scan_mode, dwell_time, chan_num, chan_list);
 }
 
 INT wifi_steering_setGroup(UINT steeringgroupIndex, wifi_steering_apConfig_t *cfg_2, wifi_steering_apConfig_t *cfg_5)
 {
-    return RETURN_ERR;
+    return ipc_wifi_steering_setGroup(steeringgroupIndex, cfg_2, cfg_5);
 }
 
 INT wifi_steering_clientSet(UINT steeringgroupIndex, INT apIndex, mac_address_t client_mac, wifi_steering_clientConfig_t *config)
 {
-    return RETURN_ERR;
+    return ipc_wifi_steering_clientSet(steeringgroupIndex, apIndex, client_mac, config);
 }
 
 INT wifi_steering_clientRemove(UINT steeringgroupIndex, INT apIndex, mac_address_t client_mac)
 {
-    return RETURN_ERR;
+    return ipc_wifi_steering_clientRemove(steeringgroupIndex, apIndex, client_mac);
 }
 
 INT wifi_steering_clientMeasure(UINT steeringgroupIndex, INT apIndex, mac_address_t client_mac)
 {
-    return RETURN_ERR;
+  	return RETURN_ERR;
 }
 
 INT wifi_steering_clientDisconnect(UINT steeringgroupIndex, INT apIndex, mac_address_t client_mac, wifi_disconnectType_t type, UINT reason)
 {
-    return RETURN_ERR;
+    return ipc_wifi_steering_clientDisconnect(steeringgroupIndex, apIndex, client_mac, type, reason);
 }
 
 INT wifi_steering_eventRegister(wifi_steering_eventCB_t event_cb)
 {
-    return RETURN_ERR;
+    return ipc_wifi_steering_eventRegister(event_cb);
 }
 
 INT wifi_steering_eventUnregister(void)
 {
-    return RETURN_ERR;
+    return ipc_wifi_steering_eventUnregister();
 }
 
 INT wifi_getApAssociatedDeviceRxStatsResult(INT radioIndex, mac_address_t *clientMacAddress, wifi_associated_dev_rate_info_rx_stats_t **stats_array, UINT *output_array_size, ULLONG *handle)
 {
-    return RETURN_ERR;
+    return ipc_wifi_getApAssociatedDeviceRxStatsResult(radioIndex, clientMacAddress, stats_array, output_array_size, handle); 
 }
 
 INT wifi_getApAssociatedDeviceTxStatsResult(INT radioIndex, mac_address_t *clientMacAddress, wifi_associated_dev_rate_info_tx_stats_t **stats_array, UINT *output_array_size, ULLONG *handle)
+{
+    return ipc_wifi_getApAssociatedDeviceTxStatsResult(radioIndex, clientMacAddress, stats_array, output_array_size, handle);
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_setRadioDfsAtBootUpEnable(INT radioIndex, BOOL enabled)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_setProxyArp(INT apIndex, BOOL enabled)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_setCountryIe(INT apIndex, BOOL enabled)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_getLayer2TrafficInspectionFiltering(INT apIndex, BOOL *enabled)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_getCountryIe(INT apIndex, BOOL *enabled)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_setP2PCrossConnect(INT apIndex, BOOL disabled)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_getDownStreamGroupAddress(INT apIndex, BOOL *disabled)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_getProxyArp(INT apIndex, BOOL *enabled)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_applyGASConfiguration(wifi_GASConfiguration_t *input_struct)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_getBssLoad(INT apIndex, BOOL *enabled)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_pushApHotspotElement(INT apIndex, BOOL enabled)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_setBssLoad(INT apIndex, BOOL enabled)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_getApInterworkingServiceEnable(INT apIndex, BOOL *output_bool)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_sendActionFrame(INT apIndex, mac_address_t MacAddr, UINT frequency, UCHAR *frame, UINT len)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_setDownStreamGroupAddress(INT apIndex, BOOL disabled)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_setLayer2TrafficInspectionFiltering(INT apIndex, BOOL enabled)
 {
     return RETURN_ERR;
 }
@@ -3262,7 +3279,7 @@
 
 INT wifi_getRadioChannelStats(INT radioIndex,wifi_channelStats_t *input_output_channelStats_array,INT array_size)
 {
-    return RETURN_ERR;
+    return ipc_wifi_getRadioChannelStats(radioIndex, input_output_channelStats_array, array_size);
 }
 
 INT wifi_getApAssociatedDeviceDiagnosticResult2(INT apIndex,wifi_associated_dev2_t **associated_dev_array,UINT *output_array_size)
@@ -3282,7 +3299,7 @@
 
 INT wifi_getApMacAddressControlMode(INT apIndex, INT *output_filterMode)
 {
-    return RETURN_ERR;
+  	return RETURN_ERR;
 }
 
 INT wifi_setApCsaDeauth(INT apIndex, INT mode)
@@ -3297,22 +3314,22 @@
 
 INT wifi_getNeighboringWiFiStatus(INT radio_index, wifi_neighbor_ap2_t **neighbor_ap_array, UINT *output_array_size)
 {
-    return RETURN_ERR;
+    return ipc_wifi_getNeighboringWiFiStatus(radio_index, neighbor_ap_array, output_array_size);
 }
 
 INT wifi_getSSIDNameStatus(INT apIndex, CHAR *output_string)
 {
-    return RETURN_ERR;
+    return ipc_wifi_getSSIDNameStatus(apIndex, output_string);
 }
 
 INT wifi_getApAssociatedDeviceStats(INT apIndex, mac_address_t *clientMacAddress, wifi_associated_dev_stats_t *associated_dev_stats, ULLONG *handle)
 {
-    return RETURN_ERR;
+    return ipc_wifi_getApAssociatedDeviceStats(apIndex, clientMacAddress, associated_dev_stats, handle);
 }
 
 INT wifi_getBSSTransitionActivation(UINT apIndex, BOOL *activate)
 {
-    return RETURN_ERR;
+    return ipc_wifi_getBSSTransitionActivation(apIndex, activate);
 }
 
 INT wifi_getApIndexFromName(CHAR *inputSsidString, INT *output_int)
@@ -3320,11 +3343,94 @@
     return RETURN_ERR;
 }
 
+INT wifi_getMultiPskClientKey(INT apIndex, mac_address_t mac, wifi_key_multi_psk_t *key)
+{
+	return RETURN_ERR;
+}
+
+INT wifi_getAssociationReqIEs(UINT apIndex, const mac_address_t *clientMacAddress, CHAR *req_ies, UINT req_ies_size, UINT *req_ies_len)
+{
+    return ipc_wifi_getAssociationReqIEs(apIndex, clientMacAddress, req_ies, req_ies_size, req_ies_len);
+}
+
+INT wifi_setNeighborReports(UINT apIndex, UINT numNeighborReports, wifi_NeighborReport_t *neighborReports)
+{
+    return ipc_wifi_setNeighborReports(apIndex, numNeighborReports, neighborReports);
+}
+
 /**
  OPENSYNC WIFI HAL EXTENSIONS END
 */
 
 
+
+//**************************************************************************************************
+// CCSP-ONE-WIFI API BEGIN  //
+//--------------------------------------------------------------------------------------------------
+INT wifi_getApInterworkingElement(INT apIndex, wifi_InterworkingElement_t *output_struct)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_pushApRoamingConsortiumElement(INT apIndex, wifi_roamingConsortiumElement_t *infoElement)
+{
+	return RETURN_ERR;
+}
+// CCSP-ONE-WIFI API END  //
+//**************************************************************************************************
+
+
+
+//**************************************************************************************************
+// PLUMEWIFI HAL API BEGIN //
+//--------------------------------------------------------------------------------------------------
+int wifi_RMBeaconRequestCallbackRegister(unsigned int apIndex, wifi_RMBeaconReport_callback cb_fn)
+{
+    for (unsigned int vap_index = 0; vap_index < MAX_VAP; vap_index++) {
+        ipc_wifi_RMBeaconRequestCallbackRegister(vap_index, cb_fn);
+    }
+    return RETURN_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+int wifi_RMBeaconRequestCallbackUnregister(unsigned int apIndex, wifi_RMBeaconReport_callback cb_fn)
+{
+    return ipc_wifi_RMBeaconRequestCallbackUnregister(apIndex, cb_fn);
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_hostapNlConnect(INT radioIndex)
+{
+	return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_hostapNlDisconnectAll(void)
+{
+    return RETURN_ERR;
+}
+
+//--------------------------------------------------------------------------------------------------
+int wifi_BTMQueryRequest_callback_register(unsigned int apIndex,
+        wifi_BTMQueryRequest_callback btmQueryCallback,
+        wifi_BTMResponse_callback btmResponseCallback)
+{
+    for (unsigned int vap_index = 0; vap_index < MAX_VAP; vap_index++) {
+        ipc_wifi_BTMQueryRequest_callback_register(vap_index, btmQueryCallback, btmResponseCallback);
+    }
+    return RETURN_OK;
+}
+
+//--------------------------------------------------------------------------------------------------
+INT wifi_getApAssociatedDeviceTidStatsResult(INT radioIndex, mac_address_t *clientMacAddress, wifi_associated_dev_tid_stats_t *tid_stats, ULLONG *handle)
+{
+    return RETURN_ERR;
+}
+// PLUMEWIFI HAL API END //
+//**************************************************************************************************
+
+
 #ifdef _WIFI_HAL_TEST_
 int main(int argc,char **argv)
 {
